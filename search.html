<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    
    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- 웹폰트 추가-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- syntax.css 추가-->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="데이터 사이언티스트를 꿈꾸는 블로그입니다." />
    <link rel="shortcut icon" href="https://keonju2.github.io/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://keonju2.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="주건나's Blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="데이터 사이언티스트를 꿈꾸는 블로그입니다." />
    <meta property="og:url" content="https://keonju2.github.io/search" />
    <meta property="og:image" content="https://keonju2.github.io/assets/built/images/blog-cover1.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/monkeykeonju" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="데이터 사이언티스트를 꿈꾸는 블로그입니다." />
    <meta name="twitter:url" content="https://keonju2.github.io/" />
    <meta name="twitter:image" content="https://keonju2.github.io/assets/built/images/blog-cover1.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="주건나's Blog" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "주건나's Blog",
        "logo": "https://keonju2.github.io/"
    },
    "url": "https://keonju2.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://keonju2.github.io/assets/built/images/blog-cover1.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://keonju2.github.io/search"
    },
    "description": "데이터 사이언티스트를 꿈꾸는 블로그입니다."
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://keonju2.github.io/">주건나's Blog</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-R" role="menuitem"><a href="/tag/programming/">프로그래밍 언어</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/project/">프로젝트</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/license/">자격증</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/study/">이론 공부</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
                <a class="social-link social-link-fb" href="https://facebook.com/monkeykeonju" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>
</a>
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "programming-baekjoon6": {
        "title": "백준 (6) &lt;br&gt; (3085, 2563, 4673, 5635, 11170)",
            "author": "keonju",
            "category": "",
            "content": "백준 관련 글    백준 (1) (2557, 8958, 1000, 1001, 1008, 2935, 2753, 2884, 5063, 4101)    백준 (2) (1018, 1085, 1181, 1259, 1436, 1654, 1874, 1920)    백준 (3) 문자열 알고리즘(11720, 8958, 1152, 10809, 1157, 9012, 11718)    백준 (4) (1157, 1546, 2577, 2675, 2908, 1018, 1436, 1259, 7568, 10250)    백준 (5) 정렬 알고리즘(2750,11399,2751,1427, 10989,1181,11650)    백준 (6) (3085, 2563, 4673, 5635, 11170)# 백준 5문제를 풀어보았다.  ###### 중복되는 문제도 있습니다## 3085번 사탕 게임  &lt;https://www.acmicpc.net/problem/3085&gt;  먼저 보드는 한 글자당 리스트 한 요소를 차지하게끔 이중으로 만든다.  check 함수를 통해 보드에 연속된 사탕이 몇개인지 만들어준다.  그 다음 for문을 통해 값들을 하나씩 변경해보고 가장 많은 값을 찾는다.  ```pythonnum=int(input())board=[]answer=0for i in range(num):    candy=list(input())    board.append(candy)```    3    CCP    CCP    PCC    ```pythondef check(board):    n=len(board)    answer=1 #연속된 사탕의 결과        for i in range(n):        count=1        for j in range(1, n):            if board[i][j] == board[i][j-1]:  #열에서 같다면 +1 해주기                count += 1            else:                count=1    # 같지 않다면 1로 초기화            if count &gt; answer:                answer = count # 가장 큰 값을 answer로 반환        count=1 # 행 결과를 찾기 위한 초기화        for j in range(1, n):            if board[j][i] == board[j-1][i]: # 행에서 최대값 찾기                count += 1            else:                count=1            if count &gt; answer:                answer = count    return answer``````pythonanswer=0for i in range(num):    for j in range(num):        if j+1 &lt; num:            board[i][j],board[i][j+1] =board[i][j+1],board[i][j] # 열에서 값 바꾸기            temp=check(board) # 최대 개수 확인하기            if temp &gt; answer:                answer = temp # 가장 많은 값으로 저장            board[i][j], board[i][j+1] = board[i][j+1], board[i][j] # 값 초기화하기        if i+1 &lt; num: #행에서 마찬가지로 진행            board[i][j], board[i+1][j] = board[i+1][j], board[i][j]            temp=check(board)            if temp &gt; answer:                answer = temp                        board[i][j], board[i+1][j] = board[i+1][j], board[i][j]            print(answer)```    3    ## 2563번 색종이&lt;https://www.acmicpc.net/problem/2563&gt;  100 * 100의 흰 색종이를 먼저 만들어준다.  다음 입력받은 색종이만큼 0을 1로 바꿔주면 중복도 해결하면서 검은색을 표시할 수 있다.  1이 된 숫자의 부분만 세면 된다.  ```pythonpaper=[[0 for i in range(101)] for j in range(101)]for i in range(int(input())):    x,y=map(int,input().split())    for j in range(x,x+10):        for k in range(y,y+10):            paper[j][k]=1result=0for i in paper:    result += i.count(1)print(result)```    3    3 7    15 7    5 2    260    ## 4673번 색종이&lt;https://www.acmicpc.net/problem/4673&gt;  for문을 통해 숫자들의 셀프 넘버를 구해서 초기 [1:10000]의 리스트에서 셀프 넘버가 나오면 제거해주었다.```pythonself_num=[i for i in range(1,10001)]for i in range(1,10001):    total=i    num=str(i)    for j in range(len(num)):        total=total+int(num[j])    if total in self_num:        self_num.remove(total)for i in range(len(self_num)):    print(self_num[i])```    1    3    5    7    9    20    31    42    53    64    75    86    97    108    110    121    132    143    154    165    176    187    198    209    211    222    233    244    255    266    277    288    299    310    312    323    334    345    356    367    378    389    400    411    413    424    435    446    457    468    479    490    501    512    514    525    536    547    558    569    580    591    602    613    615    626    637    648    659    670    681    692    703    714    716    727    738    749    760    771    782    793    804    815    817    828    839    850    861    872    883    894    905    916    918    929    940    951    962    973    984    995    1006    1021    1032    1043    1054    1065    1076    1087    1098    1109    1111    1122    1133    1144    1155    1166    1177    1188    1199    1210    1212    1223    1234    1245    1256    1267    1278    1289    1300    1311    1313    1324    1335    1346    1357    1368    1379    1390    1401    1412    1414    1425    1436    1447    1458    1469    1480    1491    1502    1513    1515    1526    1537    1548    1559    1570    1581    1592    1603    1614    1616    1627    1638    1649    1660    1671    1682    1693    1704    1715    1717    1728    1739    1750    1761    1772    1783    1794    1805    1816    1818    1829    1840    1851    1862    1873    1884    1895    1906    1917    1919    1930    1941    1952    1963    1974    1985    1996    2007    2022    2033    2044    2055    2066    2077    2088    2099    2110    2112    2123    2134    2145    2156    2167    2178    2189    2200    2211    2213    2224    2235    2246    2257    2268    2279    2290    2301    2312    2314    2325    2336    2347    2358    2369    2380    2391    2402    2413    2415    2426    2437    2448    2459    2470    2481    2492    2503    2514    2516    2527    2538    2549    2560    2571    2582    2593    2604    2615    2617    2628    2639    2650    2661    2672    2683    2694    2705    2716    2718    2729    2740    2751    2762    2773    2784    2795    2806    2817    2819    2830    2841    2852    2863    2874    2885    2896    2907    2918    2920    2931    2942    2953    2964    2975    2986    2997    3008    3023    3034    3045    3056    3067    3078    3089    3100    3111    3113    3124    3135    3146    3157    3168    3179    3190    3201    3212    3214    3225    3236    3247    3258    3269    3280    3291    3302    3313    3315    3326    3337    3348    3359    3370    3381    3392    3403    3414    3416    3427    3438    3449    3460    3471    3482    3493    3504    3515    3517    3528    3539    3550    3561    3572    3583    3594    3605    3616    3618    3629    3640    3651    3662    3673    3684    3695    3706    3717    3719    3730    3741    3752    3763    3774    3785    3796    3807    3818    3820    3831    3842    3853    3864    3875    3886    3897    3908    3919    3921    3932    3943    3954    3965    3976    3987    3998    4009    4024    4035    4046    4057    4068    4079    4090    4101    4112    4114    4125    4136    4147    4158    4169    4180    4191    4202    4213    4215    4226    4237    4248    4259    4270    4281    4292    4303    4314    4316    4327    4338    4349    4360    4371    4382    4393    4404    4415    4417    4428    4439    4450    4461    4472    4483    4494    4505    4516    4518    4529    4540    4551    4562    4573    4584    4595    4606    4617    4619    4630    4641    4652    4663    4674    4685    4696    4707    4718    4720    4731    4742    4753    4764    4775    4786    4797    4808    4819    4821    4832    4843    4854    4865    4876    4887    4898    4909    4920    4922    4933    4944    4955    4966    4977    4988    4999    5010    5025    5036    5047    5058    5069    5080    5091    5102    5113    5115    5126    5137    5148    5159    5170    5181    5192    5203    5214    5216    5227    5238    5249    5260    5271    5282    5293    5304    5315    5317    5328    5339    5350    5361    5372    5383    5394    5405    5416    5418    5429    5440    5451    5462    5473    5484    5495    5506    5517    5519    5530    5541    5552    5563    5574    5585    5596    5607    5618    5620    5631    5642    5653    5664    5675    5686    5697    5708    5719    5721    5732    5743    5754    5765    5776    5787    5798    5809    5820    5822    5833    5844    5855    5866    5877    5888    5899    5910    5921    5923    5934    5945    5956    5967    5978    5989    6000    6011    6026    6037    6048    6059    6070    6081    6092    6103    6114    6116    6127    6138    6149    6160    6171    6182    6193    6204    6215    6217    6228    6239    6250    6261    6272    6283    6294    6305    6316    6318    6329    6340    6351    6362    6373    6384    6395    6406    6417    6419    6430    6441    6452    6463    6474    6485    6496    6507    6518    6520    6531    6542    6553    6564    6575    6586    6597    6608    6619    6621    6632    6643    6654    6665    6676    6687    6698    6709    6720    6722    6733    6744    6755    6766    6777    6788    6799    6810    6821    6823    6834    6845    6856    6867    6878    6889    6900    6911    6922    6924    6935    6946    6957    6968    6979    6990    7001    7012    7027    7038    7049    7060    7071    7082    7093    7104    7115    7117    7128    7139    7150    7161    7172    7183    7194    7205    7216    7218    7229    7240    7251    7262    7273    7284    7295    7306    7317    7319    7330    7341    7352    7363    7374    7385    7396    7407    7418    7420    7431    7442    7453    7464    7475    7486    7497    7508    7519    7521    7532    7543    7554    7565    7576    7587    7598    7609    7620    7622    7633    7644    7655    7666    7677    7688    7699    7710    7721    7723    7734    7745    7756    7767    7778    7789    7800    7811    7822    7824    7835    7846    7857    7868    7879    7890    7901    7912    7923    7925    7936    7947    7958    7969    7980    7991    8002    8013    8028    8039    8050    8061    8072    8083    8094    8105    8116    8118    8129    8140    8151    8162    8173    8184    8195    8206    8217    8219    8230    8241    8252    8263    8274    8285    8296    8307    8318    8320    8331    8342    8353    8364    8375    8386    8397    8408    8419    8421    8432    8443    8454    8465    8476    8487    8498    8509    8520    8522    8533    8544    8555    8566    8577    8588    8599    8610    8621    8623    8634    8645    8656    8667    8678    8689    8700    8711    8722    8724    8735    8746    8757    8768    8779    8790    8801    8812    8823    8825    8836    8847    8858    8869    8880    8891    8902    8913    8924    8926    8937    8948    8959    8970    8981    8992    9003    9014    9029    9040    9051    9062    9073    9084    9095    9106    9117    9119    9130    9141    9152    9163    9174    9185    9196    9207    9218    9220    9231    9242    9253    9264    9275    9286    9297    9308    9319    9321    9332    9343    9354    9365    9376    9387    9398    9409    9420    9422    9433    9444    9455    9466    9477    9488    9499    9510    9521    9523    9534    9545    9556    9567    9578    9589    9600    9611    9622    9624    9635    9646    9657    9668    9679    9690    9701    9712    9723    9725    9736    9747    9758    9769    9780    9791    9802    9813    9824    9826    9837    9848    9859    9870    9881    9892    9903    9914    9925    9927    9938    9949    9960    9971    9982    9993    ## 5635번 생일&lt;https://www.acmicpc.net/problem/5635&gt;  for문을 통해 글자들을 입력받고 연-월-일 부분을 정수형으로 치환한다.  sort와 lambda를 이용해서 오름차순으로 정렬하면 가장 마지막 사람이 어리고 가장 처음 사람이 나이가 가장 많을 것이다.  ```pythonpeople=[]for i in range(int(input())):    person=list(input().split(' '))    person[1]=int(person[1])    person[2]=int(person[2])    person[3]=int(person[3])    people.append(person)people.sort(key=lambda x:[x[3],x[2],x[1]])print(people[-1][0])print(people[0][0])```    4    Mickey 1 10 1991    Jerry 18 9 1990    Tom 15 8 1993    Alice 30 12 1990    [['Jerry', 18, 9, 1990], ['Alice', 30, 12, 1990], ['Mickey', 1, 10, 1991], ['Tom', 15, 8, 1993]]    Tom    Jerry    ## 11170번 0의 개수&lt;https://www.acmicpc.net/problem/11170&gt;  a,b 두 숫자 사이의 모든 숫자들을 붙여서 하나의 글자로 만들어준다음 count함수를 사용하였다.  ```pythonfor i in range(int(input())):    a,b=input().split()        word=''    for j in range(int(a),int(b)+1):        word=word+str(j)        print(word.count('0'))```    3    0 10    2    33 1005    199    1 4    0    ",
        "url": "/programming-baekjoon6"
    }
    ,
    
    "programming-baekjoon5": {
        "title": "백준 (5) 정렬 알고리즘 &lt;br&gt; (2750,11399,2751,1427, &lt;br&gt; 10989,1181,11650,2309)",
            "author": "keonju",
            "category": "",
            "content": "백준 관련 글    백준 (1) (2557, 8958, 1000, 1001, 1008, 2935, 2753, 2884, 5063, 4101)    백준 (2) (1018, 1085, 1181, 1259, 1436, 1654, 1874, 1920)    백준 (3) 문자열 알고리즘(11720, 8958, 1152, 10809, 1157, 9012, 11718)    백준 (4) (1157, 1546, 2577, 2675, 2908, 1018, 1436, 1259, 7568, 10250)    백준 (5) 정렬 알고리즘(2750,11399,2751,1427, 10989,1181,11650)    백준 (6) (3085, 2563, 4673, 5635, 11170)#  정렬에 관련된 8문제를 풀어보았다.  ###### 중복되는 문제도 있습니다&lt;https://www.acmicpc.net/problemset?sort=ac_desc&amp;algo=158&gt;     정렬은 병합 정렬, 분할 정복, 퀵 정렬, 힙 정렬, 계수 정렬 등 공부할 개념들이 많았다.  ## 2750번 수 정렬하기&lt;https://www.acmicpc.net/problem/2750&gt;      sorted를 통해 입력받은 숫자들을 오름차순으로 정렬하는 문제였다.  ```pythonnum=int(input())n_list=sorted([int(input()) for i in range(num)])for j in n_list:    print(j)```    5    5    2    3    4    1    1    2    3    4    5    ## 11399번 ATM   &lt;https://www.acmicpc.net/problem/11399&gt;    total과 temp를 통해 temp에서는 n번째 사람이 걸리는 시간을 저장해주고 total에 전 사람까지 걸린 시간을 저장해주었다.```pythonpeople=int(input()) #사람수 입력time=sorted(list(map(int,input().split()))) #map으로 split된 값을 list로 저장 후 sorted로 오름차순 정렬```    5    3 1 4 3 2    ```pythontotal=0 #n번째 사람까지 걸린 시간의 총합temp=0 #n번째 사람이 기다린 시간for i in time:    temp=temp+i #n번째 사람이 기다린 시간= 이전 사람이 기다린 시간+ 그 사람이 걸리는 시간    total=temp+total print(total)```    32    ## 2751번 수 정렬하기 2   &lt;https://www.acmicpc.net/problem/2751&gt;    ###### pypy3으로 제출하면 이렇게도 해결이 된다.  ```pythonnum=int(input())n_list=sorted([int(input()) for i in range(num)])for j in n_list:    print(j)```    5    5    4    3    2    1    1    2    3    4    5    ###### 하지만 python3로는 시간초과가 발생한다.  이 문제는 앞에 2750번과 다르게 N의 범위가 100만까지이다. 따라서 시간복잡도 문제라고 볼 수 있다.  시간복잡도를 할 수 있는 방법은 병합 정렬, 퀵 정렬, 힙 정렬이 있다.  ###### 병합 정렬병합 정렬은 데이터를 절반씩 나누어 끝까지 갔다가 다시 절반씩 합치면서 정렬하는 방법이다.  이 때 분할 단계에서 깊이가 logN에 비례하지만, 깊이별로 수행되는 merge의 시간복잡도는 O(N)이다.  1. 리스트 요소가 1개가 될때까지 나눈다.  2. 분리한 왼쪽리스트, 오른쪽 리스트의 각각 첫번째 요소를 비교해 더 작은 값을 결과 리스트에 저장한다.  3. 저장한 값은 리스트에서 지운다.  4. 두 리스트 모두 요소가 하나도 안남을 때까지 반복한다.  ###### 병합 정렬을 이용한 풀이병합 정렬을 이용할 때는 먼저 def로 병합 정렬 함수를 만들어준다.  모든 리스트 요소가 1개가 될때까지 나눈다.  따라서 중간값을 기준으로 나누어주면 된다.  여기서도 input 대신 sys.stdin.readline()를 사용해야한다.  ```pythonimport sysn=int(input())unsorted=[]result=[]# 분할def Divided(list):    #길이가 1일때 중단    if len(list)&lt;=1:        return list    #중간값을 기준으로 리스트 분할    mid = len(list)//2    less_part=list[:mid]    more_part=list[mid:]    less_part=Divided(less_part)    more_part=Divided(more_part)    return merge(less_part,more_part)#비교와 합병def merge(less,more):    merged_list=[]    l,h=0,0    #less와 more을 돌면서 대소관계 비교 후 작은 곳에 append    while l&lt;len(less) and h&lt;len(more):        if less[l]&lt;more[h]:            merged_list.append(less[l])            l=l+1        else:            merged_list.append(more[h])            h=h+1    merged_list+=less[l:]    merged_list+=more[h:]    return merged_listfor i in range(n):    num=int(input())    unsorted.append(num)result=Divided(unsorted)for i in result:    print(i)```    7    6    4    3    1    2    5    7    1    2    3    4    5    6    7    ## 1427번 소트인사이드  &lt;https://www.acmicpc.net/problem/1427&gt;     N을 문자열로 입력받아서 각 글자들을 list에 넣고 sort를 해줘도 오름차순으로 정렬이 된다.  따라서 reverse를 통해 내림차순으로 만들어주고 join으로 다시 문자열로 만들어주었다.  ```pythonN=input()```    2143    ```pythonprint(''.join(sorted([i for i in N],reverse=True)))```    4321    ## 10989 수 정렬하기 3  &lt;https://www.acmicpc.net/problem/10989&gt;  ###### 메모리 초과가 발생하는 코드sys.stdin.readline()를 사용하여도, pypy3를 사용하여도 메모리 초과가 발생한다.  아마 첫째 줄에 범위가 1&lt;=N&lt;=10000000 까지 넓고 수 또한 10000 이하의 자연수로 매우 크기 때문이 아닐까 생각된다.  ```pythonnum=int(input())n_list=sorted([int(input()) for i in range(num)])for j in n_list:    print(j)```    10    5    2    3    1    4    2    3    5    1    7    1    1    2    2    3    3    4    5    5    7    ###### 계수 정렬(counting sort) 알고리즘  따라서 검색을 해보니 계수 정렬 알고리즘이라는 방식이 있다고 한다.  계수 정렬의 특징은&gt; 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있다.  &gt; 매우 빠르다.  &gt; 모든 범위를 담을 수 있는 리스트를 선언해야한다.  즉, 일단 범위가 되는 모든 자연수의 크기와 같은 리스트를 생성해야한다.  숫자를 입력 받으면 해당하는 숫자가 나타내는 리스트 인덱스에 +1을 해주는 것이다.  따라서 숫자가 입력 받았으면 1 이상이 나올 것이고 아니라면 0일 것이다.  입력받은 숫자의 빈도를 물어본다면 인덱스와 값을 출력시키면 될 것이고  입력받은 숫자를 정렬한다면 0이 아닌 리스트의 인덱스 값을 순서대로 출력해주면 된다.  ###### 계수 정렬을 이용한 풀이    따라서 nlist를 통해 자연수 범위만큼 0인 리스트를 선언해주었다.  그 다음 입력받은 n값을 nlist의 인덱스에서 찾아서 +1 해주었다.  그 다음 nlist의 값들을 찾으면서 0보다 큰 값들만 찾아주고 그 값들의 인덱스만 추출해주면 된다.  이 문제도 input을 사용하면 시간 초과가 발생한다.  ```python#계수 정렬을 이용한 풀이import sysn=int(input())nlist=[0 for i in range(10001)]for i in range(n):    nlist[int(input())]+=1for i in range(len(nlist)):    if nlist[i]&gt;0:        for j in range(nlist[i]):            print(i)```    10    5    2    3    1    4    2    3    5    1    7    1    1    2    2    3    3    4    5    5    7    ## 11650번 좌표 정렬하기  &lt;https://www.acmicpc.net/problem/11650&gt;   sort() 함수에서 key 파라미터에 (x,y)를 넣어주면 x를 우선 정렬해주고 y를 정렬해준다.  주피터 노트북을 사용하면서 sys.stdin.readline()을 사용한 적이 없었는데 주피터 노트북에선 stdin이 잘 구현이 안된다고 한다.  따라서 밑에 코드에는 input()을 사용하였지만 백준에 제출할 때는 sys.stdin.readline()으로 제출하였다.  input()을 하게되면 시간 초과 결과가 나오고 pypy3로 제출하면 input()을 사용해도 괜찮은 것으로 보인다.  ```pythonimport sysN=input()nlist=[]for i in range(int(N)):    x,y=map(int,input().split()) #실제 제출에서는 sys.stdin.readline()을 사용하였다    nlist.append((x,y))```    5    3 4    1 1    1 -1    2 2    3 3    ```pythonnlist.sort(key=lambda x: (x[0],x[1]))for j in nlist:    print(j[0],j[1])```    1 -1    1 1    2 2    3 3    3 4    ## 2309번 일곱 난쟁이  &lt;https://www.acmicpc.net/problem/2309&gt;   이 문제는 input()을 사용하여도 시간초과는 나오지 않는다.  n_list에서 두 가지씩 고르는 모든 경우의 수를 찾아야하기 때문에 이중 for문을 사용하였다.  j는 i와 같이 않아야하기 때문에 i+1로 중복을 피했다.  모든 값의 합이 100 이 되기 때문에 두 개씩 골라서 빼주었을 때 100 이 되면 그 두 값을 remove를 통해 제거하고 sorted로 내림차순 정렬한 뒤 출력해주면 된다.  첫 for문이 끝나야하기 때문에 조건에 맞는 답을 골라주면 멈추면 된다.  ```pythonn_list=[]for i in range(1,10):    tall=int(input())    n_list.append(tall)```    20    7    23    19    10    15    25    8    13```pythonresult= sum(n_list)for i in range(9):    for j in range(i+1,9):        if result-(n_list[i]+n_list[j])==100:            a,b=n_list[i],n_list[j]            n_list.remove(a)            n_list.remove(b)            n_list=sorted(n_list)            for k in range(7):                print(n_list[k])            break    if len(n_list)==7:        break```    7    8    10    13    19    20    23",
        "url": "/programming-baekjoon5"
    }
    ,
    
    "study-ml2": {
        "title": "머신러닝 정리 (2) &lt;br&gt; 지도학습 (2)",
            "author": "keonju",
            "category": "",
            "content": "머신러닝 공부 관련 글    머신러닝 정리 (1)-지도학습 (1)    머신러닝 정리 (2)-지도학습 (2)머신러닝 정리 (2) - 지도학습 (2)본 문서는 [파이썬 라이브러리를 활용한 머신러닝] 책을 공부하면서 요약한 내용입니다.또 데이터 청년 캠퍼스 수업과 학교 수업에서 배운 내용들도 함께 정리했습니다.글의 순서는 [파이썬 라이브러리를 활용한 머신러닝]에 따라 진행됩니다.코드는 밑에 링크에 공개되어있기 때문에 올리지않습니다.소스 코드: https://github.com/rickiepark/introduction_to_ml_with_python지도학습 (2)  결정 트리  결정 트리의 앙상블  배깅, 엑스트라 트리, 에이다부스트          배깅      엑스트라 트리      선형 모델      에이다부스트        커널 서포트 벡터 머신  신경망 (딥러닝)  분류 예측의 불확실성 추정          결정 함수      예측 확률      다중 분류에서의 불확실성      결정 트리Decision Tree 결정 트리는 분류와 회귀 문제에서 사용되는 모델입니다.스무고개처럼 예/아니오로 나눌 수 있는 조건을 통해서 결정에 다다르게 됩니다.질문과 정답은 노드가 되고 특히 마지막 노드는 리프라고 합니다. 결정트리의 구조는 왼쪽 하단에 사진처럼 가장 위에는 Root node, 질문과 답을 연결하는 Edge, 내부의 Internal node, 마지막 노드는 Leaf node, 그리고 Depth로 구성됩니다.결정 트리 만들기 결정 트리를 학습한다는 것은 정답에 가장 빨리 도달하는 예/아니오 질문 (TEST) 목록을 학습한다는 뜻입니다.보통 데이터들은 예/아니오 특성으로 구분되지 않고  연속적인 특성을 가진 2차원 데이터 셋에서 보통 ‘특성 i는 값 a보다 큰가?’의 형태와 같은 테스트를 가집니다.이 데이터들을 X[1]&lt;=0.6인 테스트로 나누어 봅니다.알고리즘은 가능한 모든 테스트에서 타깃 값에 대해 가장 많은 정보를 가진 것을 고르게 됩니다.따라서 X[1]&lt;=0.6인 테스트를 선택하게 됩니다.결정 트리에서 각 테스트는 하나의 축을 따라 데이터를 나눕니다.하나의 질문당 하나의 축을 만들어서 영역이 한 개의 타깃값을 가질 때까지 반복됩니다. 결정 트리의 멈춤 조건입니다.즉, 미리 정의한 조건들이 없다면 가지를 만들 수 있을 때까지 만드는 것을 알 수 있습니다.결정트리의 예측은 그 포인트가 어느 리프에 들어갈지 확인하는 것인데 분류는 타깃 값 중 다수인 것이 예측 결과가 되고 회귀의 경우 리프 노드의 훈련 데이터 평균값이 결과로 출력됩니다.결정 트리 복잡도 제어하기 결정 경계가 클래스 포인트에 멀리 떨어진 이상치에 민감하게 되어 모든 리프 노드가 순수 노드가 될 때까지 진행하면 모델이 복잡해지고 과대적합이 발생합니다.과대적합을 막기 위한 방법은 크게 사전가지치기, 사후 가지치기 두 가지입니다.사전 가지치기는 이름에서 알 수 있듯이 모델을 만들 때 깊이나 리프의 개수 또는 테스트의 최소 개수를 미리 제한하는 것입니다.미리 제한하기 때문에 정말로 중요한 포인트를 분류하지않을 수 있습니다.사후 가지치기 역시 이름에서 알 수 있듯이 트리가 만들어진 뒤 포인트가 적은 노드를 삭제 혹은 병합하게 되는데 에러감소 프루닝, 룰 포스트 프루닝 같은 방법들이 있습니다.참고에러감소 프루닝  모든 노드를 프루닝 대상으로 고려노드 제거 후 검증을 통해 제거 전, 후 정확도 비교제거 전보다 정확도가 낮아지기 전까지 반복룰 포스트 프루닝  의사결정 트리를 룰셋으로 변환 (룰은 루트부터 리프까지의 경로)이 룰셋 속성들에 정확도를 떨어뜨리는 속성을 제거프루닝 완료 후 정확도 순으로 정렬해 이 순서대로 적용결정 트리는 다음과 같이 만들 수 있고 정확도를 확인할 수 있습니다.Default값은 모든 리프가 순수 노드가 되는 모델을 만들기 때문에 훈련 세트의 정확도가 100%가 됩니다.하지만 트리가 무한정 깊어지고 복잡해지고 일반화가 잘 되지 않습니다.from sklearn.tree import DecisionTreeClassifiercancer = load_breast_cancer()X_train, X_test, y_train, y_test = train_test_split(    cancer.data, cancer.target, stratify=cancer.target, random_state=42)tree = DecisionTreeClassifier(random_state=0)tree.fit(X_train, y_train)print(\"훈련 세트 정확도: {:.3f}\".format(tree.score(X_train, y_train)))print(\"테스트 세트 정확도: {:.3f}\".format(tree.score(X_test, y_test)))훈련 세트 정확도: 1.000테스트 세트 정확도: 0.937과대적합 때문에 반드시 훈련 세트의 정확도가 테스트 정확도와 비례하지 않아서 max_depth와 같은 파라미터를 통해 과대적합을 줄이고 테스트 세트 정확도를 높일 수 있습니다.tree = DecisionTreeClassifier(max_depth=4, random_state=0)tree.fit(X_train, y_train)print(\"훈련 세트 정확도: {:.3f}\".format(tree.score(X_train, y_train)))print(\"테스트 세트 정확도: {:.3f}\".format(tree.score(X_test, y_test)))훈련 세트 정확도: 0.988테스트 세트 정확도: 0.951결정 트리 분석 결정 트리를 생성하고 시각화하기 위해서는 다음과 같은 모듈이 필요합니다.# 트리 모델 생성from sklearn.tree import DecisionTreeClassifier # 트리의 시각화_1from sklearn.tree import export graphviz # 트리의 시각화_2 (.dot 파일을 만들지 않아도 가능)from sklearn.tree import plot_tree 그래프를 시각화하는 코드는 다음과 같이 쓸 수 있습니다.# graphviz 이용from sklearn.tree import export_graphvizexport_graphviz(tree, out_file=\"tree.dot\", class_names=[\"악성\", \"양성\"],                feature_names=cancer.feature_names, impurity=False, filled=True)#plot_treefrom sklearn.tree import plot_treeplot_tree(tree, class_names=[\"악성\", \"양성\"], feature_names=cancer.feature_names,         impurity=False, filled=True, rounded=True, fontsize=4)filled=True를 넣어주면 다음과 같이 색상이 들어가는 트리 모델을 얻을 수 있습니다.트리의 특성 중요도tree.feature_importane를 통해 특성 중요도를 알 수 있습니다.특성 중요도는 0부터 1 사이에 존재하는데 0은 전혀 사용되지 않은 특성, 1은 완벽하게 타깃 클래스를 예측한 특성을 의미합니다. 특성 중요도가 낮다는 유용하지 않다가 아닌 모델이 만들어질 때 특성을 선택하지 않았거나 특성과 중복되는 정보가 있다는 것을 의미합니다.전체 합은 1이 되고 따라서 특성중요도는 ‘이 모델이 만들어지는데 어떤 특성의 비율이 높은가?’ 정도의 해석이라고 생각하면 될 것 같습니다.Worst_radius만 보고 ‘반지름이 크면 양성이다?’ 를 알 수 없는 것처럼 특성 중요도는 어떤 클래스를 지지하는지 알려주지 않습니다.결정 트리의 회귀도 분류와 비슷하게 적용됩니다.단, 결정 트리를 회귀 모델로 사용하게 되면 훈련 데이터 범위 밖의 정보가 없어서 그 부분에 대한 예측이 불가능하게 됩니다.다음 모델은 트리 복잡도에 제한을 두지않아서 훈련 데이터는 완벽하게 예측하지만 데이터 범위 밖으로 나가면 마지막 포인트로 예측값을 출력합니다.따라서 트리 모델은 가격의 등락과 같은 예측을 할 때는 좋은 예측 모델을 만들 수 있지만 시계열 데이터에서는 데이터가 가진 시간 범위 밖의 예측은 안되기 때문에 잘 맞지 않습니다.장단점과 매개변수장점  해석력이 높습니다.데이터의 스케일에 구애받지 않습니다. 정규화나 표준화 같은 전처리 불필요합니다.특성의 스케일이 다르거나 이진특성, 연속적인 특성이 혼합되어도 잘 작동합니다.단점  과대적합되는 경향이 있어 일반화 성능이 좋지 않습니다.  축 평행을 구분하여 일부 관계에서 모델링이 어려움이 있습니다. 훈련 데이터에 대한 약간의 변경은 전체 결정논리에 큰 변화를 야기하여 샘플에 민감합니다.            매개변수      설명                  min_samples_split      - 노드를 분할하기 위한 최소한의 샘플 데이터수 → 과적합을 제어하는데 사용  - Default = 2 → 작게 설정할 수록 분할 노드가 많아져 과적합 가능성 증가              min_samples_leaf      - 리프노드가 되기 위해 필요한 최소한의 샘플 데이터수- min_samples_split과 함께 과적합 제어 용도- 불균형 데이터의 경우 특정 클래스의 데이터가 극도로 작을 수 있으므로 작게 설정 필요              max_features      - 최적의 분할을 위해 고려할 최대 feature 개수- Default = None → 데이터 세트의 모든 피처를 사용- int형으로 지정 →피처 갯수 / float형으로 지정 →비중- sqrt 또는 auto : 전체 피처 중 √(피처개수) 만큼 선정- log : 전체 피처 중 log2(전체 피처 개수) 만큼 선정              max_depth      - 트리의 최대 깊이- default = None→ 완벽하게 클래스 값이 결정될 때 까지 분할 또는 데이터 개수가 min_samples_split보다 작아질 때까지 분할- 깊이가 깊어지면 과적합될 수 있으므로 적절히 제어 필요              max_leaf_nodes      리프노드의 최대 개수      여기서 max_depth, max_leaf_nodes,min_samples_leaf 중 하나만 지정해도 과대적합을 막는데 충분한 역할을 합니다.결정 트리의 앙상블Ensemble앙상블은 여러 머신러닝 모델을 연결하여 더 강력한 모델을 만드는 기법입니다.책에서는 결정 트리의 앙상블로 한정하고 가장 많이 쓰이는 랜덤포레스트나 부스팅 모델은 트리 기반 모델이지만 앙상블은 다른 분류 모델을 결합하여 사용할 수도 있습니다.  Voting – 서로 다른 알고리즘을 가진 분류기를 결합  Bagging – 각각의 분류기는 모두 같은 유형의 알고리즘 기반, 모델을 다양하게 만들기 위해 데이터를 재구성 (랜덤포레스트)  Boosting – 맞추기 어려운 데이터에 대해 좀 더 가중치를 두어 학습 (Adaboost, Gradient Boosting)  Stacking – 모델의 output 값을 새로운 독립변수로 사용앙상블의 조건입니다.랜덤 포레스트랜덤 포레스트는 조금씩 다른 결정 트리의 묶음입니다.      데이터의 일부에 과대적합되는 경향을 이용하여 서로 다른 방향으로 과대적합된 트리를 많이 만들어 그 결과를 평균냄으로써 예측 성능은 유지되면서 결과적으론 과대적합이 줄어드는 아이디어에 기초합니다.결정 트리를 많이 만들면서 각 트리는 타깃 예측을 잘 해야 하고 다른 트리와 구별되어야 합니다.따라서 무작위성을 주입하는데 트리를 만들 때 사용하는 데이터 포인트를 무작위로 선택하거나 분할 테스트에서 특성을 무작위로 선택하는 방법을 이용합니다.랜덤 포레스트 구축from sklearn.ensemble import RandomForestClassifier (or RandomForestRegressor)n_estimators로 생성할 트리의 개수를 정합니다.부트스트랩 샘플은 n_samples개의 데이터 포인트 중에서 n_samples 횟수만큼 무작위로 중복 가능하게 반복 추출하는 것을 의미합니다.따라서 데이터 셋이 원래 크기와 같지만 누락되거나 중복되는 데이터가 만들어집니다.각 노드에서 전체 특성을 대상으로 최선의 테스트를 찾는 것이 아닌 알고리즘이 각 노드에서 후보 특성을 무작위로 선택한 후 이 후보들 중에서 최선의 테스트를 찾습니다. (max_features) 부트스트랩 샘플링을 통해 트리가 조금씩 다른 데이터셋을 이용해 만들어지도록 합니다.각 노드에서 특성의 일부만 사용하기 때문에 트리의 각 분기는 각기 다른 특성 부분 집합을 사용됩니다.max_features=n_features는 특성 선택에 무작위성이 들어가지 않습니다. (부트스트랩 샘플링에는 무작위성 그대로 입니다.)max_feature=1 트리의 분기는 테스트할 특성을 고를 필요가 없게 되고 무작위로 선택한 특성의 임계값 찾기만 하면 됩니다.max_feature이 커지면 랜덤 포레스트 트리들은 매우 비슷하고 가장 두드러진 특성으로 데이터에 잘 맞춰질 것이고 작으면 트리들은 서로 많이 달라지고 각 트리는 데이터에 맞추기 위해 깊이가 깊어지게 됩니다.랜덤 포레스트 예측의 경우 알고리즘이 모델에 있는 모든 트리의 예측을 만듭니다.회귀의 경우 이 예측들을 평균하여 최종 예측을 만듭니다.분류의 경우 약한 투표 전략을 사용합니다.약한 투표 전략은 각 알고리즘이 가능성 있는 출력 레이블의 확률을 제공하고 예측한 확률을 평균으로 가장 높은 확률을 가진 클래스가 예측값이 됩니다.참고로 강한 투표 전략은 다수의 분류기가 결정한 예측값을 최대로 하는 것을 말합니다.랜덤 포레스트 분석랜덤 포레스트 훈련 모델from sklearn.ensemble import RandomForestClassifierfrom sklearn.datasets import make_moonsX, y = make_moons(n_samples=100, noise=0.25, random_state=3)X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, random_state=42)forest = RandomForestClassifier(n_estimators=5, random_state=2)forest.fit(X_train, y_train)부트스트랩 샘플링 때문에 한쪽 트리에 나타나는 훈련 포인트가 다른 트리에는 포함되지 않을 수 있어 각 트리는 불완전하지만 랜덤포레스트의 결과는 좋은 결정경계를 보여줍니다.단일 트리와 다르게 랜덤 포레스트에서 가장 특성 중요도가 높은 특성은 worst perimeter입니다.랜덤 포레스트에서 더 많은 특성이 0 이상의 중요도를 갖고 따라서 더 넓은 시각으로 데이터를 바라볼 수 있습니다.X_train, X_test, y_train, y_test = train_test_split(    cancer.data, cancer.target, random_state=0)forest = RandomForestClassifier(n_estimators=100, random_state=0)forest.fit(X_train, y_train)print(\"훈련 세트 정확도: {:.3f}\".format(forest.score(X_train, y_train)))print(\"테스트 세트 정확도: {:.3f}\".format(forest.score(X_test, y_test)))훈련 세트 정확도: 1.000테스트 세트 정확도: 0.972랜덤 포레스트에선 훈련 데이터 정확도가 100% 이지만 단일 트리에 비해서 테스트 정확도가 상승한 것을 확인 할 수 있습니다.장단점과 매개변수장점  매개변수 튜닝을 많이 하지 않습니다. 데이터의 스케일에 구애받지 않습니다. 단일 트리의 단점을 보완하고 장점을 그대로 가지고 있습니다.단점  랜덤 포레스트의 트리는 특성의 일부만 사용하므로 결정 트리보다 더 깊어지는 경향이 있습니다.다른 random_state를 지정하면 전혀 다른 모델이 만들어집니다.텍스트 데이터와 같은 차원이 높고 희소한 데이터에 잘 작동하지 않습니다.선형 모델에 비해 많은 메모리를 사용하며 훈련과 예측이 느림            매개변수      설명                  n_estimators      - 결정트리의 갯수를 지정- Default = 10 (0.22버전부터 100)- 무작정 트리 갯수를 늘리면 성능 좋아지는 것 대비 시간이 걸릴 수 있음              min_samples_split      - 노드를 분할하기 위한 최소한의 샘플 데이터수 → 과적합을 제어하는데 사용- Default = 2 → 작게 설정할 수록 분할 노드가 많아져 과적합 가능성 증가              min_samples_leaf      - 리프노드가 되기 위해 필요한 최소한의 샘플 데이터수- min_samples_split과 함께 과적합 제어 용도- 불균형 데이터의 경우 특정 클래스의 데이터가 극도로 작을 수 있으므로 작게 설정 필요              max_features      - 최적의 분할을 위해 고려할 최대 feature 개수- Default = ‘auto’ (결정트리에서는 default가 none이었음)- int형으로 지정 →피처 갯수 / float형으로 지정 →비중- sqrt 또는 auto : 전체 피처 중 √(피처개수) 만큼 선정 (RandomForestClassifier-sqrt(n_feature), RandomForestRegressor-n_feature)- log : 전체 피처 중 log2(전체 피처 개수) 만큼 선정              max_depth      - 트리의 최대 깊이- default = None→ 완벽하게 클래스 값이 결정될 때 까지 분할 또는 데이터 개수가 min_samples_split보다 작아질 때까지 분할- 깊이가 깊어지면 과적합될 수 있으므로 적절히 제어 필요              max_leaf_nodes      리프노드의 최대 개수      N_estimatiors는 클수록 좋고 max_features와 max_depth와 같은 사전 가지치기 옵션은 단일 트리와 같이 주어집니다.그레이디언트 부스팅 회귀 트리이름은 회귀이지만 회귀와 분류 모두 사용됩니다. (GradientBoostingClassifier, GradientBoostingRegressor)그레이디언트 부스팅은 이전 트리의 오차를 보완하는 방식으로 순차적으로 트리를 만듭니다.따라서 기본적으로 무작위성이 없습니다.대신 강력한 사전 가지치기가 사용되고 깊지 않은 트리를 사용합니다.각 트리는 데이터의 일부에 대해서만 예측을 잘 수행하여 트리가 많이 추가될수록 성능이 향상됩니다.이때 손실 함수를 정의하고 경사 하강법을 사용해서 다음 값을 보정합니다.random_state=0 만 입력했을 때from sklearn.ensemble import GradientBoostingClassifier​X_train, X_test, y_train, y_test = train_test_split(    cancer.data, cancer.target, random_state=0)​gbrt = GradientBoostingClassifier(random_state=0)gbrt.fit(X_train, y_train)​print(\"훈련 세트 정확도: {:.3f}\".format(gbrt.score(X_train, y_train)))print(\"테스트 세트 정확도: {:.3f}\".format(gbrt.score(X_test, y_test)))훈련 세트 정확도: 1.000테스트 세트 정확도: 0.965random_state=0, max_depth=1 을 입력했을 때gbrt = GradientBoostingClassifier(random_state=0, max_depth=1)gbrt.fit(X_train, y_train)​print(\"훈련 세트 정확도: {:.3f}\".format(gbrt.score(X_train, y_train)))print(\"테스트 세트 정확도: {:.3f}\".format(gbrt.score(X_test, y_test)))훈련 세트 정확도: 0.991테스트 세트 정확도: 0.972random_state=0, learning_rate=0.01을 입력했을 때gbrt = GradientBoostingClassifier(random_state=0, learning_rate=0.01)gbrt.fit(X_train, y_train)print(\"훈련 세트 정확도: {:.3f}\".format(gbrt.score(X_train, y_train)))print(\"테스트 세트 정확도: {:.3f}\".format(gbrt.score(X_test, y_test)))훈련 세트 정확도: 0.988테스트 세트 정확도: 0.965훈련 세트의 정확도가 100%로 과대적합이 된 모델은 max_depth나 learning_rate로 보완할 수 있습니다.Random_state는 고정시켜야 같은 모델이 나오는 것을 볼 수 있습니다.Learning_rate는 오차에 곱을 해서 예측값을 업데이트 해주는 값입니다.랜덤 포레스트에 비해 그레이디언트 부스팅은 특성들이 더 적습니다.안정성에서는 랜덤 포레스트가 더 좋지만 그레이디언트가 성능적으로 더 좋은 모습을 보여줄수 있습니다.참고XGBoost  XGBoost는 데이터 별 오류를 다음 round 학습에 반영 시킨다는 측면에서 기존 Gradient Boosting과 큰 차이는 없음Gradient Boosting과 달리 학습을 위한 목적식(loss function)에 Regularization term이 축가되어 모델이 과적합 되는 것을 방지해줌Regularization term을 통해 XGBoost는 복잡한 모델에 패널티를 부여함LighGBM  XGBoost와 다르게 lear-wise loss 사용 (loss를 더 줄일 수 있음)XGBoost 대비 2배 이상 빠른 속도 (동일 파라미터 기준)과대적합에 민감하여, 대량의 학습데이터를 필요로 함장단점과 매개변수장점  이진 특성이나 연속적인 특성에도 잘 작동합니다. 데이터의 스케일에 구애받지 않습니다.단점  매개변수의 조정이 필수입니다.휸련시간이 깁니다.  차원이 높고 희소한 데이터에 잘 작동하지 않습니다.N_estimators가 클수록 랜덤 포레스트는 좋았지만 그래이디언트 부스팅에서는 과대적합될 가능성이 높아집니다.N_estimator을 정하고 난 뒤에 learning_rate를 정하게 되는데 learning_rate를 낮추면 비슷한 복잡도의 모델을 만들기 위해 더 많은 트리를 추가해야합니다.            매개변수      설명                  n_estimators      - 트리의 개수를 지정- 커지면 모델이 복잡해지고 과대적합 가능성 높아짐              learning_rate      - 관례상 n_estimators를 맞추고 learning_rate를 찾음 - 이전 트리의 오차를 보정하는 정도              n_iter_no_change / validation_fraction      -조기 종료를 위한 매개변수 (default값: n_iter_no_change =None (조기 종료 x), validation_fraction=0.1) - validation_fraction 비율만큼 검증 데이터로 사용하여 n_iter_no_change 만큼 반복하여 향상되지 않으면 훈련 종료              max_depth / max_leaf_nodes      -각 트리의 복잡도를 낮춤 - max_depth는 보통 매우 작게 설정하며 트리의 깊이가 5보다 깊어지지 않게 함      배깅, 엑스트라 트리, 에이다부스트Baggingfrom sklearn.ensemble import BaggingClassifier배깅은 중복을 허용한 랜덤샘플링으로 만든 훈련 세트를 사용해 분류기를 각기 다르게 학습합니다.랜덤포레스트는 배깅의 일종이지만 설명변수도 무작위로 선택하는 것이 차이가 있습니다.predict_proba() 지원하면 메서드를 통해 확률값을 평균하여 예측을 수행합니다. (지원하지 않는다면 가장 빈도가 높은 클래스 레이블)oob_score=True로 지정하면 매개변수는 부트스트래핑에 포함되지 않은 샘플로 훈련된 모델을 평가할 수 있습니다. (OOB 오차, default=False)from sklearn.linear_model import LogisticRegressionfrom sklearn.ensemble import BaggingClassifierbagging = BaggingClassifier(LogisticRegression(), n_estimators=100, oob_score=True, n_jobs=-1, random_state=42)bagging.fit(Xc_train, yc_train)print(\"훈련 세트 정확도: {:.3f}\".format(bagging.score(Xc_train, yc_train)))print(\"테스트 세트 정확도: {:.3f}\".format(bagging.score(Xc_test, yc_test)))print(\"OOB 샘플의 정확도: {:.3f}\".format(bagging.oob_score_))훈련 세트 정확도: 0.953테스트 세트 정확도: 0.951OOB 샘플의 정확도: 0.946배깅은 랜덤포레스트와 달리 max_samples에 부트스트랩 샘플의 크기를 정할 수 있습니다. 또한 로지스틱 회귀가 들어갈 수도 있고 결정 트리가 들어갈 수도 있습니다.Extra Tree후보 특성을 무작위로 분할한 다음 최적의 분할을 찾습니다.엑스트라 트리도 랜덤 포레스트와 비슷하지만 splitter=‘random’을 사용합니다. 랜덤 포레스트는 splitter=‘best’가 고정입니다.Splitter=‘best’의 의미는 모든 변수의 정보 이득을 계산하고 그중 가장 설명력이 높은 변수를 선택하는 것입니다.또한 부트스트랩 샘플링을 적용하지 않습니다. 무작위성을 증가시키면 모델 편향은 늘어나지만 분산이 감소하는 모습을 보입니다.개별 트리는 매우 복잡하지만 결정 경계는 안정적입니다.계산 비용은 위 splitter에서의 feature의 차이 때문에 랜덤 포레스트보다 적지만  일반화 성능을 높이려면 많은 트리를 만들어야합니다.from sklearn.ensemble import ExtraTreesClassifierxtree = ExtraTreesClassifier(n_estimators=100, n_jobs=-1, random_state=0)xtree.fit(Xc_train, yc_train)print(\"훈련 세트 정확도: {:.3f}\".format(xtree.score(Xc_train, yc_train)))print(\"테스트 세트 정확도: {:.3f}\".format(xtree.score(Xc_test, yc_test))훈련 세트 정확도: 1.000테스트 세트 정확도: 0.972Adaptive Boosting이전의 모델이 잘못 분류한 샘플에 가중치를 높여서 다음 모델을 훈련합니다.훈련된 각 모델은 성능에 따라 가중치 부여합니다.예측을 만들 때는 모델이 예측한 레이블을 기준으로 모델의 가중치를 합산하여 가장 높은 값을 가진 레이블을 선택합니다.AdaBoostClassifier은 기본값으로 DecisionTreeClassifier(max_depth=1)를 갖습니다.AdaBoostRegressor은 기본값으로 DecisionTreeRegressor(max_depth=3)을 갖습니다. (base_estimator을 이용하여 다른 모델 지정 가능)에이다 부스팅의 원리와 수식예측정확도와 가중치의 곱의 합이 되어 높은 정확도를 만들게 됩니다.from sklearn.ensemble import AdaBoostClassifierada = AdaBoostClassifier(n_estimators=100, random_state=42)ada.fit(Xc_train, yc_train)print(\"훈련 세트 정확도: {:.3f}\".format(ada.score(Xc_train, yc_train)))print(\"테스트 세트 정확도: {:.3f}\".format(ada.score(Xc_test, yc_test)))훈련 세트 정확도: 1.000테스트 세트 정확도: 0.986커널 서포트 벡터 머신커널 서포트 벡터 머신은 보통 SVM이라고 한다.입력 데이터에서 단순한 초평면으로 정의되지 않는 더 복잡한 모델을 만들 수 있도록 확장한 것이다.분류와 회귀 모두 사용 가능하다. (SVC는 분류, SVR은 회귀)from sklearn.svm import LinearSVC #선형 모델LinearSVC(max_iter=)from sklearn.svm import SVCSVC(kernel='',C=,gamma=) # kernel, C, gamma 파라미터 존재선형 모델과 비선형 특성선형 모델은 직선으로만 데이터 포인트를 나눌 수 있어 밑에 같은 데이터는 잘 들어맞지 않는다.SVM 모델은 3차원에서 2차원으로 투영해본다면 더이상 선형 모델이 아니다.커널 기법커널 기법은 실제로 데이터를 확장하지 않고 확장된 특성에 대한 데이터 포인트들의 거리를 계산한다.$ (특성1)^2 * (특성2)^5 $하는 다항식 커널이 있고 가우시안 커널로 불리우는 RBF 커널이 있다.가우시안 커널은 차원이 무한한 특성 공간에 매핑하는 것이다.모든 차수의 모든 다항식을 고려하지만 특성의 중요도는 고차항이 될수록 줄어든다.SVM 이해하기두 클래스 사이에 경계한 데이터 포인트들을 서포트 벡터라고 한다.새로운 데이터 포인트에 대해 예측하려면 각 서포트 벡터와의 거리를 측정한다.서포트 벡터의 중요도는 훈련 과정에서 학습하는데 dual_coef_ 속성에 저장된다.가우시안 커널 공식 사진가우시안 커널에 의해 계산되며 $ X_1, X_2 $는 데이터 포인트이며 $ ||X_1 - X_2|| $는 유클리디안 거리이고 $Γ$ 은 가우시안 커널의 폭을 제어하는 매개변수이다.SVM 매개변수 튜닝$Γ$는 가우시안 커널 폭의 역수에 해당하는데 하나의 훈련 샘플이 미치는 영향의 범위를 결정한다.(1~0 사이의 범위이다.)작은 값은 넓은 영역을 뜻하고, 큰 값은 영향이 미치는 범위가 제한적이다.즉 커널의 반경이 클수록 훈련 샘플의 영향 범위도 커진다.작은 $Γ$ 값은 모델의 복잡도를 낮출 수 있다.C 매개 변수는 규제 매개변수이다. dual_coef_값을 제한합니다.작은 C는 매우 제약이 큰 모델을 만들고 각 데이터 포인트의 영향력이 작다.C를 증가시키면 이 포인트들이 영향을 크게 줘서 결정 경계를 휘게 만든다.SVM을 위한 데이터 전처리커널 SVM에서는 데이터셋의 특성 자릿수가 완전히 다르면 영향을 크게 미친다.따라서 특성 값을 평균이 0이고 단위 분산이 되도록 하거나, 0과 1 사이로 맞추는 방법을 많이 사용한다.(StandardScaler와 MinMaxScalar)장단점과 매개변수SVM은 저차원과 고차원의 데이터에 모두 잘 작동하지만 샘플이 많으면 잘 맞지 않는다.또한 전처리와 매개변수 설정에 신경을 많이 써야하는데 그래서 랜덤 포레스트나 그레이디언트 부스팅과 같은 전처리가 거의 필요 없는 트리 기반 모델이 선호된다.SVM은 분석도 어려워서 예측이 어떻게 결정되었는지 설명하기가 난해하다.하지만 모든 특성이 비슷한 단위이고 스케일이 비슷하다면 시도해볼 만하다.중요한 매개변수는 C이고 어떤 커널을 사용할지와 각 커널에 따른 매개변수이다.RBF는 $Γ$ 매개변수를 갖지만 다른 커널 종류도 많다.신경망 (딥러닝)다층 퍼셉트론은(MLP)는 간단하게 분류와 회귀에서 쓰일 수 있다.신경망 모델MLP는 여러 단계를 거처 결정을 만들어내는 선형 모델의 일반화된 모습이다.선형 회귀 모델의 예측 공식 사진$\\hat Y $는 x[0]에서 x[p]까지의 입력특성과 학습된 계수의 가중치의 합이다.퍼셉트론 사진왼쪽 노드는 입력 특성을 나타내며 연결선은 학습된 계수를 표현하고 오른쪽 노드는 입력의 가중치 합, 즉 출력을 나타낸다.MLP는 가중치 합을 만드는 과정이 여러 번 반복되며 먼저 중간 단계를 구성하는 은닉 유닛을 계산하고 이를 이용하여 최종 결과를 산출하기 위해 다시 가중치 합을 계산한다.다중 퍼셉트론 사진각 은닉 유닛의 가중치 합을 계산한 후 결과에 비선형 함수인 렐루나 하이퍼볼릭 탄젠트, 시그모이드 함수를 적용합니다.회귀 분석 사진w는 입력 x와 은닉층 h 사이의 가중치이고, v는 은닉층 h와 출력 $\\hat Y$ 사이의 가중치입니다.w와 v는 훈련 데이터에서 학습하고 x는 입력 특성이며 $ \\hat Y $는 계산된 출력, h는 중간 계산값 입니다.신경망 튜닝더 복잡도가 낮은 모델을 만들고 싶다면 hidden_layer_size를 통해 은닉 유닛의 개수를 줄인다.은닉 유닛을 추가하거나, 은닉층을 추가하거나 활성화함수를 바꾸면 더 매끄러운 결정 경계를 얻을 수도 있다.선형 분류와 리지 회귀 처럼 L2 페널티를 사용해서 가중치를 0에 가깝게 감소시킬 수도 있다.(default는 매우 낮다)신경망에서는 학습을 시작하기 전에 가중치를 무작위로 설정하며 이 무작위한 초기화가 모델의 학습에 영향을 준다.따라서 같은 매개변수를 사용하더라도 초깃값이 다르면 모델이 많이 달라질 수 있다.신경망도 입력 특성이 평균은 0 분산이 1이 되도록 변형하는 것이 좋다.은닉 유닛에서 작은 가중치를 가진 특성은 모델에 덜 중요하다고 추론할 수 있다.from sklearn.neural_network import MLPClassifier # MLP분류MLPClassifier(solver='',activation='',random_state=,hidden_layer_sizes=[,],max_itter=,alpha=) #solver에 최적화 알고리즘,activation에 활성화 함수 ,hidden_layer_size로 은닉 유닛의 개수 설정(default=100),max_itter은 반복 횟수,alpha는 L2 페널티장단점과 매개변수머신러닝 알고리즘을 뛰어넘는 성능을 보일 수 있지만 학습이 오래걸리고 데이터 전처리를 주의해서 해야한다.모든 특성이 같은 의미를 가지면 SVM, 다른 종류의 특성이라면 트리 기반 메딜이 더 잘 작동할 수 있다.신경망의 복잡도 추정가장 중요한 매개변수는 은닉층의 개수와 각 은닉층의 유닛 수이다.복잡도에 관해 연관된 측정치는 학습된 가중치 또는 계수의 수이다.특성이 100개 은닉 유닛 100개인 이진 분류라면 입력층과 첫 번째 은닉층 사이에는 편향을 포함하여 $ 100 * 100 + 100 = 10100 $개의 가중치가 있습니다.은닉층과 출력층 사이에 $ 100 * 1 + 1 = 101 $개의 가중치가 더 있어 가중치는 10201개 이다.이렇게 가중치는 은닉층을 추가할수록 훨씬 커지게 된다.매개변수를 조정하는 일반적인 방법은 충분히 과대적합되어 문제를 해결할만한 큰 모델을 만든 뒤 훈련 데이터가 충분히 학습될 수 있다고 생각되면 신경망 구조를 줄이거나 규제 강화를 위해 alpha 값을 증가시켜 일반화 성능을 향상시킨다.층의 개수, 층당 유닛 개수, 규제, 비선형성으로 모델 구성을 할 수 있으며, solver 매개변수를 통해서 학습시키는 방법을 지정할 수 있다.solver의 경우 기본값은 adam이고 데이터 스케일에 민감하다.lbfgs는 안정적이지만 규모가 크면 시간이 오래 걸린다sgd는 momentum과 nesterovs_momentom의 영향을 받는데 다른 여러 매개변수와 함께 튜닝하여 최선의 결과를 만들 수 있다.분류 예측의 불확실성 추정decision_function과 predict_proba로 추정 할 수 있다.결정 함수decision_function의 반환값의 크기는 (n_samples,)이며각 샘플이 하나의 실수 값을 반환한다.모델이 데이터 포인트가 양성 클래스인 클래스 1에 속한다고 믿는 정도이다.즉, 음수값은 다른 클래스에 속함을 의미한다.값의 범위는 데이터와 모델 파라미터에 따라 달라지게 된다.예측 확률predict_proba의 출력은 각 클래스에 대한 확률이고 이진 분류에서 이 값의 크기는 항상 (n_samples,2)이다.두 클래스의 확률 합은 1이므로 두 클래스 중 하나는 50% 이상의 확신을 가질 것이고 그 클래스가 예측값이 된다.데이터에 있는 불확실성이 얼마나 이 값에 잘 반영되는지는 모델과 매개변수 설정에 달렸다.그래서 과대적합된 모델 혹은 잘못된 예측도 예측의 확신이 강한 편이다.복잡도가 낮을 수록 예측에 불확실성이 더 많다.불확실성과 모델의 정확도가 동등하면 이 모델이 보정되었다고 한다.다중 분류에서의 불확실성다중 분류에서도 decision_funcion과 predict_proba를 사용할 수 있다.decision_function에서는 (n_samples, n_classes)가 결과값이 된다.글 클래스에 대한 확신 점수를 담고 그 수치가 크면 그 클래스일 가능성이 크다.데이터 포인트마다 점수들에서 가장 큰 값을 찾아 예측 결과를 재현할 수 있다.predict_proba는 (n_samples,n_classes)가 출력값이 된다.마찬가지로 각 데이터 포인트에서 클래스 확률의 합은 1이다.argmax 함수를 적용해서 예측 결과를 재현할 수 있지만 클래스가 문자열이거나 정수형을 사용하지만 연속적이지 않고 0부터 시작하지 않을 수 있다.따라서 predict 결과와 decision_function, predict_proba의 결과를 비교하기 위해서는 분류기의 classes_ 속성을 사용해 클래스의 실제 이름을 얻어야 한다.",
        "url": "/study-ML2"
    }
    ,
    
    "programming-baekjoon4": {
        "title": "백준 (4) &lt;br&gt; (1157, 1546, 2577, 2675, 2908, &lt;br&gt; 1018, 1436, 1259, 7568, 10250)",
            "author": "keonju",
            "category": "",
            "content": "백준 관련 글    백준 (1) (2557, 8958, 1000, 1001, 1008, 2935, 2753, 2884, 5063, 4101)    백준 (2) (1018, 1085, 1181, 1259, 1436, 1654, 1874, 1920)    백준 (3) 문자열 알고리즘(11720, 8958, 1152, 10809, 1157, 9012, 11718)    백준 (4) (1157, 1546, 2577, 2675, 2908, 1018, 1436, 1259, 7568, 10250)    백준 (5) 정렬 알고리즘(2750,11399,2751,1427, 10989,1181,11650)    백준 (6) (3085, 2563, 4673, 5635, 11170)# 백준 10문제를 풀어보았다.    ###### 중복되는 문제도 있습니다  ## 1157번 단어공부  &lt;https://www.acmicpc.net/problem/1157&gt;  upper을 이용한 대문자 받기  count로 dictionary형태로 word 개수 세기개수가 중복되는 단어들이 있으므로 max_list에서 따로 추출하기조건에 맞게 최댓값이 하나면 알파벳을, 아니면 물음표를 출력하기```pythonword=input().upper()count={}for i in word:    if i not in count:        count[i]=0    count[i]+=1max_list=[j for j,k in count.items() if max(count.values())==k]if len(max_list)==1:    print(max_list[0])else:    print('?')```    Mississipi    ?    ## 1546번 평균  &lt;https://www.acmicpc.net/problem/1546&gt;  map 함수를 통해서 점수 입력받기  new_mean()이라는 함수는 문제에서 나온 $점수/최대점수*100$ 이다.  map함수를 통해 new_mean함수를 score에 모두 적용해주고 sum을 통해 총합을 구한 뒤,count로 나눠주면 된다.```pythoncount=int(input())score=list(map(int,input().split())) # 점수 입력받기```    3    40 80 60    ```pythonmax_score=max(score) # 점수 최댓값 찾기def new_mean(x): #최댓값과의 비율로 새로운 점수 만드는 함수    return x/max_score*100``````pythonprint(sum(map(new_mean,score))/count) #평균을 구하는 식```    75.0    ## 2577번 숫자의 개수  &lt;https://www.acmicpc.net/problem/2577&gt;  입력받는 숫자가 3개로 한정되어있으니까 for문을 통해서 세 숫자의 곱을 구했다.  count함수의 인덱스 0-9까지를 0-9숫자가 나왔을 때 하나씩 늘려주는 방법을 택했다.```pythonmul=1for i in range(3): # 세 숫자의 곱 구하기    a=int(input())    mul=mul*aprint(mul)```    150    266    427    17037300    ```pythoncount=[0]*10 #0-9의 개수가 들어갈 listfor j in str(mul): #str(mul)로 해줘야 for문이 성립된다.    for k in range(10): #0-9까지의 숫자를 확인하는 for문        if int(j)==k:            count[k]=count[k]+1 #숫자가 등장했을때 1 늘려주기for l in count:    print(l)```    3    1    0    2    0    0    0    2    0    0    ## 2675번 문자열 반복  &lt;https://www.acmicpc.net/problem/2675&gt;  각 글자마다 R번 반복해서 출력해주는 문제이다.  case를 통해서 몇 번 반복할지를 결정해준다.word_list에 각 단어마다 R번씩 반복하여 append해준다.join으로 리스트에 있는 단어들을 문장으로 만들어준다.```pythoncase=int(input()) # 시도할 횟수for i in range(case):     R,P=input().split() # R,P입력받기    word_list=[] #반복한 뒤 append해줄 list    for j in P: #P에 있는 글자 순서대로 반복해주기        for k in range(int(R)): #R을 str로 입력받아서 int로 변경해줘야함            word_list.append(j) #반복된 글자를 append    print(''.join(word_list)) #list안에 글자들 붙여서 출력해주기```    2    3 ABC    AAABBBCCC    5 /HTP    /////HHHHHTTTTTPPPPP    ## 2908번 상수  &lt;https://www.acmicpc.net/problem/2908&gt;  list(A)로 숫자들을 리스트화 해준다.  [::-1]로 거꾸로 뒤집어준다. A로 다시 저장하기 싫으면 reverse() 함수를 사용하면 된다.  join을 통해 숫자로 바꿔주고 int 형태로 바꿔준 뒤, max를 통해 최댓값을 찾는다.```pythonA,B=input().split() # A,B 숫자 거꾸로 만들기A=list(A)[::-1] B=list(B)[::-1]# A,B 다시 숫자로 만든 뒤 대소비교A=int(''.join(A))B=int(''.join(B))print(max(A,B))```    734 893    437    ## 1018번 체스판 다시 칠하기  &lt;https://www.acmicpc.net/problem/1018&gt;  ###### N,M 크기를  받고 보드 만들기  nXm형태의 위치를 파악하기 쉽게 리스트 형태로 받았다.  ```pythonn, m=map(int,input().split())if 8&lt;=n&lt;=50 and 8&lt;=m&lt;=50:    board = [input() for i in range(n)]```    10 13    BBBBBBBBWBWBW    BBBBBBBBBWBWB    BBBBBBBBWBWBW    BBBBBBBBBWBWB    BBBBBBBBWBWBW    BBBBBBBBBWBWB    BBBBBBBBWBWBW    BBBBBBBBBWBWB    WWWWWWWWWWBWB    WWWWWWWWWWBWB    ###### 위치가 짝수일 때와 홀수일 때로 나눠서  W, B가 아닐 때마다 점수를 추가해준 다음 가장 최소가 되는 값만 찾아내면 된다.  따라서 n * m의 보드에서 가능한 경우의 수는 n-7 * m-7이다. ex)10 13을 입력받을 경우 18가지.  8 * 8로 잘라주기 위해서 k와 l을 (i,i+8), (j,j+8)로 한정짓는다.  k+l이 홀수일 경우와 짝수일 경우, W로 시작할 경우와 B로 시작할 경우를 나눠서 모든 경우의 수를 반복문으로 확인해준다.  마지막으로 total_score에 들어있는 값들 중 최솟값을 구해준다.  ```pythontotal_score=[]# 보드에서 경우의 수 나누어주기for i in range(n-7):    for j in range(m-7):        count_w=0 #w가 아닐때        count_b=0 #b가 아닐때        #8*8 크기로 잘라주기        for k in range(i,i+8):             for l in range (j,j+8):                #각 경우의 수마다 비교해서 점수 추가하기                if (k+l)%2==0:                    if board[k][l]!='W':                                                    count_w=count_w+1                    if board[k][l]!='B':                        count_b=count_b+1                else:                    if board[k][l]!='W':                        count_b=count_b+1                    if board[k][l]!='B':                                                    count_w=count_w+1        # 점수들 한 list에 모아주기        total_score.append(count_w)        total_score.append(count_b)print(min(total_score)) #최솟값 출력```    12    ## 1436번 영화감독 숌  &lt;https://www.acmicpc.net/problem/1436&gt;  ###### 666이 적어도 3개이상 연속으로 들어가는 수를 만든다  처음에 문제를 풀 때 중간에 666이 3개 이상 들어가는 경우를 제외해서 틀렸다.  list666에 가장 작은 숫자인 666부터 '666'이 문자열로 들어가있는 숫자들을 확인해서 추가하였다.  입력받은 숫자가 list666의 길이보다 크면 계속 추가해주었고 list666[num-1]을 통하여 값을 출력해준다.  ```pythonnum=int(input())list666=[]i=666while len(list666)&lt;num:    if '666' in str(i):        list666.append(i)    i=i+1print(list666[num-1]) ```    3    2666    ## 1259번 팰린드롬수    &lt;https://www.acmicpc.net/problem/1259&gt;  ###### 앞에서 읽어도 뒤에서 읽어도 같은 숫자 찾기0을 입력하면 반복문이 끝나게 while과 if를 이용하였다.  입력받은 숫자는 위치를 찾기 편하게 문자형으로 입력받았다.  입력받은 숫자의 길이/2 만큼의 반복문을 돌리면 반대쪽은 (숫자의 길이-i-1)로 대응된다.  한가지 숫자라도 값이 다르면 False 값을 가지고 'no'를 출력하면 'yes'를 출력하는 것을 만들 때보다 길이가 짧아질 수 있다.  ```pythonwhile True:    word=input() # 숫자를 무한으로 입력받기 위해 while문 사용    quest=True # 한가지 입력값을 처리하고나서 True, False값을 True로 초기화    if word=='0': # 0을 입력하면 반복문 종료        break    else:        word_len=len(word)        for i in range(int((word_len)/2)): #단어 길이의 반만 확인하면 반대쪽 숫자와 대응된다.                if word[i]!=word[word_len-1-i]: #반대쪽 숫자와 대응하기 위해서 word_len-1-i 사용                    quest=False # 하나의 경우라도 False가 나오면 반복문 종료                    continue        if quest==False: # False가 나오면 바로 'no' 출력            print('no')        else: print('yes')```    121    yes    1231    no    12421    yes    0    ## 7568번 덩치  &lt;https://www.acmicpc.net/problem/7568&gt;  처음에 문제를 풀 때 너무 복잡하게 생각해서 무게 따로, 키 따로 점수 매기고 sort해서 index로 출력하려고 했는데 예제 문제는 옳게 나오지만 다른 경우에서 틀렸었다.  또 and 말고 &amp; 로 써서 한 번 더 틀렸는데 이건 bitwise 연산자라서 답이 다르게 나왔다.  ```python# r값 입력 받고 (무게, 키) 형태로 리스트 만들기count=int(input())human=[]for i in range(count):    weight,tall=input().split()    human.append((int(weight),int(tall)))print(human)```    5    55 185    58 183    88 186    60 175    46 155    [(55, 185), (58, 183), (88, 186), (60, 175), (46, 155)]    ```pythonfor j in human:    rank=1 # 등수는 1등 부터니까 1    for k in human:        if j[0]&lt;k[0] and j[1]&lt;k[1]: # 둘 다 k가 우세할 경우에만 rank에 1 추가-&gt;순위 하락            rank+=1    print(rank,end=' ')```    2 2 1 2 5 ```pythonfor m in human:    rank=1    for n in human:        if m[0]&lt;n[0] &amp; m[1]&lt;n[1]: # &amp;는 비트 연산자기 때문에 결과가 다르게 나온다.            rank+=1    print(rank,end=' ')```    3 1 1 1 1 ## 10250번 ACM호텔  &lt;https://www.acmicpc.net/problem/10250&gt;  1호가 우선시 된다면 H명씩 순서대로 채운다고 생각하면 편하다.  따라서 층수는 N/H의 나머지가 되고 호수는 N/H의 몫+1이 된다.  하지만 N이 H의 배수일 때, 층수가 최고층이 되기때문에 H를 대신 입력해준다.  또한 호수도 N/H의 몫과 같아지기 때문에 +1 한 것을 다시 -1 해준다.  또한 호수가 10보다 작을 때 앞에 0을 적어줘야한다.```pythonfor i in range(int(input())):    H,W,N=map(int,input().split())    floor=N%H #나머지가 층수가 된다.    order=(N//H)+1 #몫을 정수로 받은 뒤 +1해주면 호수가 된다.    if floor==0: #N이 H의 배수일 때만 따로 구분해서 값을 준다.        floor=H        order=order-1    if order&lt;10: # 호수 앞에 0을 붙여준다.        print(str(floor)+'0'+str(order))    else:        print(str(floor)+str(order))```    2    3 2 3    301    4 1 8    402```",
        "url": "/programming-baekjoon4"
    }
    ,
    
    "programming-baekjoon3": {
        "title": "백준 (3) 문자열 알고리즘 &lt;br&gt;(11720, 8958, 1152, 10809, &lt;br&gt; 1157, 9012, 11718)",
            "author": "keonju",
            "category": "",
            "content": "백준 관련 글    백준 (1) (2557, 8958, 1000, 1001, 1008, 2935, 2753, 2884, 5063, 4101)    백준 (2) (1018, 1085, 1181, 1259, 1436, 1654, 1874, 1920)    백준 (3) 문자열 알고리즘(11720, 8958, 1152, 10809, 1157, 9012, 11718)    백준 (4) (1157, 1546, 2577, 2675, 2908, 1018, 1436, 1259, 7568, 10250)    백준 (5) 정렬 알고리즘(2750,11399,2751,1427, 10989,1181,11650)    백준 (6) (3085, 2563, 4673, 5635, 11170)# 문자열에 관련된 7문항을 풀어보았다.      &lt;https://www.acmicpc.net/problemset?sort=ac_desc&amp;algo=158&gt;   ## 11720번 숫자의 합    &lt;https://www.acmicpc.net/problem/11720&gt;      ###### 공백없는 숫자들의 합구하기    방법 1. for문을 이용해서 풀기    ```pythonn=int(input())m=input()```    5    54321    range를 이용한 풀이 방법   ```pythonresult=0for i in range(n):    result=int(m[i])+resultprint(result)```    15    m을 읽어가면서 더해주는 방법   ```pythonresult=0for i in m:    result=int(i)+resultprint(result)```    15    방법 1. sum과 map을 이용해서 풀기   ```pythonprint(sum(map(int,input())))```    54321    15    ## 8958 번 OX퀴즈&lt;https://www.acmicpc.net/problem/8958&gt;  for문을 이용하여 입력받을 ox의 개수를 입력받고 for문 중첩을 이용하여 ox의 길이를 파악하고 if문으로 ox 여부를 확인하였다.ox의 연속성에 따른 점수변화를 num_score로 두고 total_score을 num_score의 합으로 설정하였다.```pythonnum=int(input())for i in range(num):    ox=input()    total_score=0    num_score=0    for i in range(len(ox)):        if (ox[i]=='O') is True:            num_score=num_score+1        else:            num_score=0        total_score=total_score+num_score    print(total_score)```    5    OOXXOXXOOO    10    OOXXOOXXOO    9    OXOXOXOXOXOXOX    7    OOOOOOOOOO    55    OOOOXOOOOXOOOOX    30    ## 1152번 단어의 개수   &lt;https://www.acmicpc.net/problem/1152&gt;  단어의 개수=공백의 위치마다 구분해줘서 입력받았다.  ```pythonsentence=list(map(str,input().split()))print(len(sentence))```    The Curious Case of Benjamin Button    6    ## 10809번 알파벳찾기&lt;https://www.acmicpc.net/problem/10809&gt;  ###### for문과 알파벳 list 선언```pythons=list(map(str,input()))alpha=list('abcdefghijklmnopqrstuvwxyz')array=[-1 for i in range(len(alpha))]for i in range(len(s)):    if array[alpha.index(s[i])]==-1:        array[alpha.index(s[i])]=ifor j in array:    print(j,end=' ')```    baekjoon    1 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 ###### 아스키코드 이용알파벳의 아스키코드는 (97,123)이다.```pythons=input()alpha=list(range(97,123))for i in alpha:    print(s.find(chr(i)),end=' ')```    baekjoon    1 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 ## 1157번 단어 공부  &lt;https://www.acmicpc.net/problem/1157&gt;  upper을 이용한 대문자 받기  count로 dictionary형태로 word 개수 세기개수가 중복되는 단어들이 있으므로 max_list에서 따로 추출하기조건에 맞게 최댓값이 하나면 알파벳을, 아니면 물음표를 출력하기```pythonword=input().upper()count={}for i in word:    if i not in count:        count[i]=0    count[i]+=1max_list=[j for j,k in count.items() if max(count.values())==k]if len(max_list)==1:    print(max_list[0])else:    print('?')```    Mississipi    ?    ## 9012번 괄호&lt;https://www.acmicpc.net/problem/9012&gt;   while문을 통해 '()'가 vps에 존재한다면 계속 replace를 통해 제거해주었다.만약 VPS 문장이었다면 문자열에 아무것도 남지않고 VPS 문장이 아니라면 어떤 문자라도 남았을 것이다.  따라서 결과물의 길이로 YES와 NO를 구분지어줬다.  ```pythonnum=int(input())for i in range(num):    vps=input()    while '()' in vps:        vps=vps.replace('()','')    if len(vps)==0:        print('YES')    else:        print('NO')```    6    (())())    NO    (((()())()    NO    (()())((()))    YES    ((()()(()))(((())))()    NO    ()()()()(()()())()    YES    (()((())()(    NO    ## 11718번 그대로 출력하기&lt;https://www.acmicpc.net/problem/11718&gt;  while True로 반복문을 만들어주고 try~except문으로 오류가 발생했을때는 멈출수 있게 해준다.```pythonwhile True:    try:        print(input())    except:        break```    Online Judge    Online Judge    ",
        "url": "/programming-baekjoon3"
    }
    ,
    
    "study-ml1": {
        "title": "머신러닝 정리 (1) &lt;br&gt; 지도학습 (1)",
            "author": "keonju",
            "category": "",
            "content": "머신러닝 공부 관련 글    머신러닝 정리 (1)-지도학습 (1)    머신러닝 정리 (2)-지도학습 (2)머신러닝 정리 (1) - 지도학습 (1)본 문서는 [파이썬 라이브러리를 활용한 머신러닝] 책을 공부하면서 요약한 내용입니다.또 데이터 청년 캠퍼스 수업과 학교 수업에서 배운 내용들도 함께 정리했습니다.글의 순서는 [파이썬 라이브러리를 활용한 머신러닝]에 따라 진행됩니다.코드는 밑에 링크에 공개되어있기 때문에 올리지않습니다.소스 코드: https://github.com/rickiepark/introduction_to_ml_with_python지도학습 (1)  분류와 회귀  일반화, 과대적합, 과소적합          모델복잡도와 데이터셋 크기의 관계        지도 학습 알고리즘          예제에 사용할 데이터셋      k-nn 모델      선형 모델      Naive Bayes 분류기      분류와 회귀분류란? 미리 정의된 가능성 있는 여러 클래스 레이블 중 하나를 예측하는 것이다.이진 분류: 예, 아니오로 구분할 수 있다. ex) 이 이메일은 스팸인가요?다중 분류: 셋 이상의 클래스로 분류된다. ex) 붓꽃 데이터회귀란? 부동소수점수(수학으로 말하면 실수)를 예측하는 것이다.어떤 사람의 여러 조건들을 통해 연간 소득을 예측하는 것과 같은 문제이다.출력 값에 연속성이 있다면 회귀 문제 없다면 분류 문제이다.일반화, 과대적합, 과소적합모델이 처음 보는 데이터에 대해 정확히 예측할 수 있다면 훈련 세트(train_set)에서 테스트 세트(test_set)으로 일반화되었다고 한다.훈련 세트에 대해서 정확히 예측하고 테스트 세트에서도 정확히 예측하길 바란다.하지만 모델이 복잡하다면 훈련 세트에서만 정확한 모델이 될 수 있다.예를 들어 “내 주변 20대가 모두 아이폰을 쓰기 때문에 다른 20대도 모두 아이폰을 살 것이다.”라는 예측을 한다면 훈련 세트가 내 주변 20대가 될 것이고 테스트 세트가 다른 모든 20대가 될 것이다.이처럼 알고리즘이 새로운 데이터를 잘 처리하는지 측정하는 방법은 테스트 세트로 평가를 해야한다.이 때, 너무 복잡한 모델을 만들어 훈련 세트에 집중되어 테스트 세트에 일반화가 부족하다면 과대적합(overfitting)이라 한다.반대로 너무 간단한 모델이라 훈련 세트에도 잘 맞지 않다면 과소적합(underfitting)이라 한다.모델복잡도와 데이터셋 크기의 관계모델의 복잡도는 훈련 데이터 셋에 담긴 입력 데이터의 다양성과 관련이 있다.데이터셋에 데이터 포인트가 다양하면 과대적합 없이 복잡한 모델을 만들 수 있다.따라서 중복이거나 비슷한 데이터를 모으는 것은 도움이 되지않는다.위의 예를 생각해보면 내 주변 20대라는 특징말고 대학 동기, 친구라는 데이터를 얻더라도 모두 20대라는 범주안에 들어갈테니 불필요한 데이터라 할 수 있다.따라서 좋은 데이터를 많이 얻는 것이 좋다.지도 학습 알고리즘각 모델의 장단점과 어떤 데이터와 어울리는지, 매개변수와 옵션의 의미를 알아보도록 하자.scikit-learn 문서를 참고하면 더 자세한 정보를 얻을 수 있다.예제에 사용할 데이터셋forge 데이터셋은 인위적으로 만든 이진 분류 데이터셋이다.k-NN 모델k-NN 모델은 단순히 데이터셋을 분류하는 것이다.k개의 레이블 중에서 어느 쪽에 더 가까운 것인지 투표를 하여 결정한다고 생각하면 이해하기 편하다.k=1일 때는 가장 가까운 것이 빨간색이었다면, k=3일 때는 파란색 두 개와 빨간색 한 개가 가까울 수도 있다.그렇게 된다면 k=3일 때는 파란색으로 분류가 된다.KNeighborClassifier(n_neighbors)을 통해 분류 모델을 만들 수 있다.이를 통해 확인할 수 있는 것은 k의 값이 커질수록 보다 단순한 모델이 만들어질 수 있다는 것이다.하지만 반드시 k가 커진다고 좋은 모델은 아니다. 정확도가 낮아질 수 있기 때문이다.KNeighborsRegressor(n_neighbors)을 통해 회귀 모델 또한 만들 수 있다.회귀 모델에서도 k를 너무 적게 쓴다면 모든 데이터를 지나가고 불안정한 모델이 만들어진다.장단점과 매개변수가장 중요한 매개변수는 거리를 재는 방법과 k값이다.보통 거리를 재는 방법은 유클리디안 거리 방식을 사용한다.장점은 이해하기가 쉬운 모델이고 조정을 많이 하지않아도 좋은 성능을 발휘할 수 있다는 것이다.단점은 훈련 세트가 크면 예측이 느려지고 전처리 과정이 중요하다는 것이다.데이터가 특성이 많거나 대부분이 0인 데이터셋에서는 잘 작동하지 않는다.선형 모델선형 모델은 $y=w[0]*x[0]+b$와 같은 모델을 갖는 예측 함수이다.y는 예측값, w와 b는 모델이 학습할 파라미터, x는 데이터의 특성이다. 위 식은 특성이 하나인 데이터 셋의 선형 함수이다.선형 회귀(최소제곱법)선형 회귀는 예측과 훈련 세트에 있는 타깃 사이의 평균제곱오차(MSE)를 최소화하는 파라미터를 찾는 것이다.평균제곱오차는 예측값과 타깃값의 차이를 제곱하여 더한 후에 샘플의 개수로 나눈 것이다.매개변수가 없는 것이 장점이지만 복잡도를 제어할 방법도 없다.LinearRegression()리지 회귀리지 회귀도 예측 함수를 사용하지만 가중치의 절댓값을 가능한 작게 만드는 목적을 갖는다.이런 제약을 규제라고 하며 L2 규제라고 한다.리지는 덜 자유로운 모델이라 과대적합이 적다. 따라서 일반화에 도움이 된다.Ridge(alpha)라소리지의 대안으로 라소가 있다. L1 규제라고도 하며 완전히 제외하는 특성이 생긴다.일부 계수가 0이 되고 모델을 이해하기 쉬워지며 중요한 특성을 찾기 쉽ㄴ다.max_itter을 조절하여 과소적합을 줄인다.Lasso(alpha, max_itter())분류용 선형 모델이진 분류의 경우 선형 회귀와 비슷하지만 가중치 합을 그냥 사용하는 대신 예측값을 임계치 0과 비교한다.0보다 작으면 -1, 크면 1이라고 예측한다. 결정 경계를 선형 함수로 잡는다.LogisticRegression과 LinearSVC가 잘 알려져있는데 규제의 강도를 결정하는 매개변수 C를 주의해야한다.C가 높으면 훈련 세트에 최대로 맞추려 노력하고 낮추면 계수 벡터(w)가 0에 가까워지도록 만든다.로지스틱 회귀분석을 제외하면 다중 클래스를 대부분 지원하지 않는다.장단점과 매개변수회귀 모델에서는 alpha, LinearSVC와 LogisticRegression에서는 C가 중요하다.alpha가 클수록, C가 작을수록 모델이 단순해진다. 로그 스케일로 최적치를 정한다.L1, L2를 결정하는 것도 정해야한다. 중요한 특성이 적으면 L1, 그렇지 않으면 L2를 이용한다.선형 모델은 학습 속도와 예측 속도가 빠르다. solver=’sag’ 옵션을 이용하면 더 빨리 처리할 수 있다.아니면 SGDClassifier과 SGDRegressor을 이용할 수도 있다.또한 선형 모델은 예측이 어떻게 만들어지는지 비교적 이해하기 쉽다. 하지만 계수의 값이 명확하지가 않다.Naive Bayes 분류기나이브 베이즈 분류기는 선형 분류기보다 훈련 속도가 빠르지만 일반화 성능이 뒤쳐진다.개별적으로 파라미터를 학습하고 특성에서 클래스별 통계를 단순하게 취합한다.GaussianNB, BernoulliNB, MultinomialNB를 scikit-learn에서 구현되어있다.GaussianNB는 연속적인, BernoulliNB는 이진 데이터를, MultinomialNB는 카운트 데이터를 적용한다.BernoulliNB는 클래스의 특성중 0이 아닌 것이 몇 개인지 센다.MultinomialNB는 클래스별 특성의 평균을, GaussianNB는 클래스별로 각 특성의 표준편차와 평균을 저장한다.MultinomialNB와 GaussianNB는 선형 모델과 예측 공식이 갖지만 coef_는 기울기 w가 아니라 의미는 다르다.장단점과 매개변수MultinomialNB와 BernoulliNB는 모델 복잡도를 조절하는 alpha변수가 하나이다.alpha가 주어지면 알고리즘이 모든 특성에 양의 값을 가진 데이터 포인트를 alpha 개수만큼 추가한다.alpha가 크면 더 완만하고 덜 복잡한 모델이 나오지만 성능 변동은 비교적 크지 않다.GaussianNB는 고차원 데이터 셋을 사용한다. 다른 모델은 데이터를 카운트하는 데 사용된다.",
        "url": "/study-ML1"
    }
    ,
    
    "programming-kaggle1": {
        "title": "캐글 (1) &lt;br&gt; Simple Matplotlib &amp; Visualization Tips 공부하기",
            "author": "keonju",
            "category": "",
            "content": "kaggle 관련 글    캐글 (1) Simple Matplotlib &amp; Visualization Tips 공부하기Simple Matplotlib &amp; Visualization Tips 공부하기https://www.kaggle.com/subinium/simple-matplotlib-visualization-tips/notebook해당과정을 필사하였으며 영어로 되어있는 부분은 다시 정리해서 적었다.  Table of Contents          Settingdpifigsizetitle        Alignments          subplots, tight_layoutsubplot2gridadd_axesadd_gridspec        Colormap          divergingqualitativesequentialscientific        Text &amp; Annotate &amp; Patch          parametertext examplepatches example        Details &amp; Example          font weight, color, size, etcHorizontal and Vertical (barplot)Border(edge) color and thicknessMain Color &amp; Sub ColorTransparencySpan        MEME          xkcd style      import numpy as npimport matplotlib as mplimport matplotlib.pyplot as plt#matplotlib.pyplot 모듈의 각각의 함수를 사용해서 간편하게 그래프를 만들고 변화를 줄 수 있습니다.import matplotlib.gridspec as gridspec# gridspec 에는 Figure 내에서 격자 모양의 패턴으로여러 Axes 레이아웃하는 데 도움이되는 클래스가 포함되어 있습니다.import seaborn as sns# Seaborn은 Matplotlib에 기반하여 제작된 파이썬 데이터 시각화 모듈print(f\"Matplotlib Version :{mpl.__version__}\")print(f\"Seaborn Version :{sns.__version__}\")import pandas as pdnetflix_titles=pd.read_csv(\"netflix_titles.csv\")Matplotlib Version :3.3.2Seaborn Version :0.11.0Setting해상도 설정 matplotlib의 기본 해상도는 떨어지는 편이라고 한다.또한 그래프의 모양에 따라서 느낌이 달라지기 때문에 크기를 많이 변경해봐야한다.plt.title() 그래프의 제목 그리기ax.set_title() 개별 서브 플롯에 제목을 추가하는 데 사용 fig.suptitle() 모든 서브 플롯에 공통 인 메인 타이틀을 추가plt.rcParams['figure.dpi'] = 200 # or dpi=200Alignmentsmatplotlib 레이아웃과 설계의 조합이다.두 개의 그래프가 한 개의 그래프보다 시각적으로 의미적으로 모두 좋다.두 개를 비교하기 위해 가장 쉬운 방법은 직사각형으로 배치하는 것이다.subplot을 통하여 초기 크기로 시작할 수 있다.subplots() 하나의 그림에 여러 플롯을 그리기 subplot2grid() 일반 그리드 내부의 특정 위치에 서브플롯을 생성 add_axes() 축 추가하기 gridspec() Figure 내에 서브플롯을 배치 add_subplot() Figure 내에 서브플롯을 배치inset_axes() 하위에 축 추가하기make_axes_locatable() 축 배치하기fig, axes = plt.subplots(2, 3, figsize=(8, 5))plt.show()# tight_layout을 통해 그래프 사이에 여유공간이 생김fig,axes =plt.subplots(2, 3, figsize=(8, 5))plt.tight_layout()plt.show()# subplot이 항상 같을 필요가 없음. 이 때 subplot2grid를 사용fig=plt.figure(figsize=(8,5)) #시작 크기 지정ax=[None for _ in range(6)]ax[0]=plt.subplot2grid((3,4),(0,0),colspan=4)ax[1]=plt.subplot2grid((3,4),(1,0),colspan=1)ax[2]=plt.subplot2grid((3,4),(1,1),colspan=1)ax[3]=plt.subplot2grid((3,4),(1,2),colspan=1)ax[4]=plt.subplot2grid((3,4),(1,3),colspan=1,rowspan=2)ax[5]=plt.subplot2grid((3,4),(2,0),colspan=3)for ix in range(6):     ax[ix].set_title('ax[{}]'.format(ix)) # subplot에 제목 생성    #ticks는 축에 표시되는 숫자    ax[ix].set_xticks([])    ax[ix].set_yticks([])    fig.tight_layout()plt.show()fig = plt.figure(figsize=(8, 5))ax = [None for _ in range(4)]#add_axes를 이해하기 힘들어서 값들을 눈에 띄게 변경해보았다.[왼쪽, 아래쪽, 너비, 높이]ax[0]=fig.add_axes([0.1,0.2,0.3,0.4])ax[1]=fig.add_axes([0.3,0.4,0.5,0.6])ax[2]=fig.add_axes([0.5,0.6,0.7,0.8]) ax[3]=fig.add_axes([0.6,0.7,0.8,0.9])for ix in range(4):    ax[ix].set_title('ax[{}]'.format(ix))    ax[ix].set_xticks([])    ax[ix].set_yticks([])plt.show()# gridspec을 이용하여 만들기fig=plt.figure(figsize=(8, 5))gs=fig.add_gridspec(3, 3) #(3x3 크기)ax=[None for _ in range(5)]ax[0]=fig.add_subplot(gs[0, :]) ax[0].set_title('gs[0, :]')ax[1]=fig.add_subplot(gs[1, :-1])ax[1].set_title('gs[1, :-1]')ax[2]=fig.add_subplot(gs[1:, -1])ax[2].set_title('gs[1:, -1]')ax[3]=fig.add_subplot(gs[-1, 0])ax[3].set_title('gs[-1, 0]')ax[4]=fig.add_subplot(gs[-1, -2])ax[4].set_title('gs[-1, -2]')for ix in range(5):    ax[ix].set_xticks([])    ax[ix].set_yticks([])plt.tight_layout()plt.show()fig,ax=plt.subplots()axin1=ax.inset_axes([0.8, 0.1, 0.15, 0.15])plt.show()from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatablefig,ax=plt.subplots(1, 1)ax_divider=make_axes_locatable(ax)ax=ax_divider.append_axes(\"right\", size=\"7%\", pad=\"2%\")plt.show()Colormaphttps://medium.com/nightingale/how-to-choose-the-colors-for-your-data-visualizations-50b2557fa335그래프에서 색상은 중요한 요소이다diverging 중앙을 기준으로 색상 변경qualitative 범주별로 색상 변경sequential 순차적으로 색상 변경scientific 다양한 색상으로 순차적 변경def cmap_plot(cmap_list, ctype):    cmaps=cmap_list    n=len(cmaps)    fig=plt.figure(figsize=(8.25, n*.20), dpi=200)    ax=plt.subplot(1, 1, 1, frameon=False, xlim=[0,10], xticks=[], yticks=[])    fig.subplots_adjust(top=0.99, bottom=0.01, left=0.18, right=0.99)    y,dy,pad = 0, 0.3, 0.08    ticks,labels = [], []    for cmap in cmaps[::-1]:        Z=np.linspace(0,1,512).reshape(1,512)        plt.imshow(Z, extent=[0,10,y,y+dy], cmap=plt.get_cmap(cmap))        ticks.append(y+dy/2)        labels.append(cmap)        y = y + dy + pad    ax.set_ylim(-pad,y)    ax.set_yticks(ticks)    ax.set_yticklabels(labels)    ax.tick_params(axis='y', which='both', length=0, labelsize=5)    plt.title(f'{ctype} Colormap', fontweight='bold', fontsize=8)    plt.show()#diverging#양쪽 끝으로 갈수록 색이 어두워진다.diverge_cmap=('PRGn', 'PiYG', 'RdYlGn', 'BrBG', 'RdGy', 'PuOr', 'RdBu', 'RdYlBu',  'Spectral', 'coolwarm_r', 'bwr_r', 'seismic_r')cmap_plot(diverge_cmap, 'Diverging')#Qualitative Colormap#최대 10가지 색상을 구성하고 점점 더 작은 범주, 다른 범주와 그룹화#유사한 색상은 피하고 채도나 밝기보다 색을 분명하게 바꾸는 것이 좋다.qualitative_cmap=('tab10', 'tab20', 'tab20b', 'tab20c',         'Pastel1', 'Pastel2', 'Paired',         'Set1', 'Set2', 'Set3', 'Accent', 'Dark2' )cmap_plot(qualitative_cmap, 'Qualitative')#Sequential Colormap#밀도 표현에 효과적이고 지도 그래프에도 효과적이다.#밝기의 변화에 따라서 값을 비교할 수 있다.sequential_cmap=('Greys', 'Reds', 'Oranges',          'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',         'Purples', 'YlGnBu', 'Blues', 'PuBu', 'GnBu', 'PuBuGn', 'BuGn',         'Greens', 'YlGn','bone', 'gray', 'pink', 'afmhot', 'hot', 'gist_heat', 'copper',          'Wistia', 'autumn_r', 'summer_r', 'spring_r', 'cool', 'winter_r')            cmap_plot(sequential_cmap, 'Sequential')netflix_date = netflix_titles[['date_added']].dropna()netflix_date['year'] = netflix_date['date_added'].apply(lambda x : x.split(', ')[-1])netflix_date['month'] = netflix_date['date_added'].apply(lambda x : x.lstrip().split(' ')[0])month_order = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][::-1]df = netflix_date.groupby('year')['month'].value_counts().unstack().fillna(0)[month_order].T#응용하면 이런 그래프도 만들어진다.plt.figure(figsize=(10,7),dpi=200)plt.pcolor(df,cmap='gist_heat_r',edgecolors='white',linewidths=2)plt.xticks(np.arange(0.5,len(df.columns),1),df.columns,fontsize=7,fontfamily='serif')plt.yticks(np.arange(0.5,len(df.index),1),df.index,fontsize=7,fontfamily='serif')plt.title('Netflix Contents Update',fontsize=12,fontfamily='serif',fontweight='bold',position=(0.23,1.0+0.02))cbar=plt.colorbar()cbar.ax.tick_params(labelsize=8) cbar.ax.minorticks_on()plt.show()#Scientific Colormapscientific_cmap=('viridis','plasma','inferno','magma')cmap_plot(scientific_cmap,'Scientific')Text &amp; Annotate &amp; Patch그래프에 세부 사항을 넣을 수 있다.ax.text와 ax.annotate는 유사하지만 다르다.ax.text 그래프의 비율 좌표를 표현ax.annotate 그래프의 좌표를 표현va, ha 현재 좌표가 텍스트의 중심, 왼쪽, 오른쪽을 결정color 색상과 RGB값 선택 bbox 텍스트를 포장하는 상자 표현facecolor와 edgecolor가 분리되어있음pad로 html에서 처럼 padding 가능boxstyle로 직사각형의 모서리 조정 가능fig,ax=plt.subplots(figsize=(5, 5), dpi=100)# Gray Boxax.text(0.1, 0.9, 'Test', color='gray', va=\"center\", ha=\"center\")# Red Boxax.text(0.3, 0.7, 'Test', color='red', va=\"center\", ha=\"center\",        bbox=dict(facecolor='none', edgecolor='red'))# Blue Boxax.text(0.5, 0.5, 'Test', color='blue', va=\"center\", ha=\"center\",        bbox=dict(facecolor='none', edgecolor='blue', pad=10.0))# Green Boxax.text(0.7, 0.3, 'Test', color='green', va=\"center\", ha=\"center\",        bbox=dict(facecolor='none', edgecolor='green', boxstyle='round'))# Blackax.text(0.9, 0.1, 'Test', color='black', va=\"center\", ha=\"center\",        bbox=dict(facecolor='none', edgecolor='black', boxstyle='round, pad=0.5'))ax.set_xticks([])ax.set_yticks([])plt.show()효과적인 표현을 위한 그림들import matplotlib.path as mpathimport matplotlib.lines as mlinesimport matplotlib.patches as mpatchesfrom matplotlib.collections import PatchCollectiondef label(xy, text):    y = xy[1] - 0.15      plt.text(xy[0], y, text, ha=\"center\", family='sans-serif', size=14)fig, ax = plt.subplots()grid = np.mgrid[0.2:0.8:3j, 0.2:0.8:3j].reshape(2, -1).Tpatches = []# 원circle = mpatches.Circle(grid[0], 0.1, ec=\"none\")patches.append(circle)label(grid[0], \"Circle\")# 직사각형rect = mpatches.Rectangle(grid[1] - [0.025, 0.05], 0.05, 0.1, ec=\"none\")patches.append(rect)label(grid[1], \"Rectangle\")# wedgewedge = mpatches.Wedge(grid[2], 0.1, 30, 270, ec=\"none\")patches.append(wedge)label(grid[2], \"Wedge\")# Polygonpolygon = mpatches.RegularPolygon(grid[3], 5, 0.1)patches.append(polygon)label(grid[3], \"Polygon\")# ellipseellipse = mpatches.Ellipse(grid[4], 0.2, 0.1)patches.append(ellipse)label(grid[4], \"Ellipse\")# arrowarrow = mpatches.Arrow(grid[5, 0] - 0.05, grid[5, 1] - 0.05, 0.1, 0.1,                       width=0.1)patches.append(arrow)label(grid[5], \"Arrow\")# path patchPath = mpath.Pathpath_data = [    (Path.MOVETO, [0.018, -0.11]),    (Path.CURVE4, [-0.031, -0.051]),    (Path.CURVE4, [-0.115, 0.073]),    (Path.CURVE4, [-0.03, 0.073]),    (Path.LINETO, [-0.011, 0.039]),    (Path.CURVE4, [0.043, 0.121]),    (Path.CURVE4, [0.075, -0.005]),    (Path.CURVE4, [0.035, -0.027]),    (Path.CLOSEPOLY, [0.018, -0.11])]codes, verts = zip(*path_data)path = mpath.Path(verts + grid[6], codes)patch = mpatches.PathPatch(path)patches.append(patch)label(grid[6], \"PathPatch\")# fancy boxfancybox = mpatches.FancyBboxPatch(    grid[7] - [0.025, 0.05], 0.05, 0.1,    boxstyle=mpatches.BoxStyle(\"Round\", pad=0.02))patches.append(fancybox)label(grid[7], \"FancyBboxPatch\")# linex, y = np.array([[-0.06, 0.0, 0.1], [0.05, -0.05, 0.05]])line = mlines.Line2D(x + grid[8, 0], y + grid[8, 1], lw=5., alpha=0.3)label(grid[8], \"Line2D\")colors = np.linspace(0, 1, len(patches))collection = PatchCollection(patches, cmap=plt.cm.hsv, alpha=0.3)collection.set_array(np.array(colors))ax.add_collection(collection)ax.add_line(line)plt.axis('equal')plt.axis('off')plt.tight_layout()plt.show()Details &amp; Examples그림에 대한 다양한 설정Horizontal and Vertical (barplot)Border(edge) color and thicknessMain Color &amp; Sub ColorTransparencySpanFont Weight, Color, Family, Size …글꼴 굵기, 크기를 설정할 수 있다.serifs와 sans serifs도 차이가 있다.fontsize, color, fontweight, fontfamily같은 키워들을 이용할 수 있다.Horizontal keyboard &amp; Vertical (barplot)x축의 수가 많으면 가독성이 낮다. 예를들면 countplot은 x축과 겹치는 경우가 발생한다.이럴 때는 수직으로 배치하면 가독성이 좋다.Border(Edge) Color &amp; Thickness (Width)별도의 테두리를 이용하여 가독성을 높일 수 있다.R에서 자주 이용한다.경계선은 밝기와 투명도를 조절하여 구별하는 것이 좋다.Main Color &amp; Sub Color화려한 색상보다 정보의 전달을 편하게 하는 것에 목적을 둔다. 그래프의 종류에 따라 색상도 변경하는 것이 좋다.특정 부품을 강조 표시할 때 목록으로 전달하는 것이 좋다.from matplotlib.ticker import FuncFormatterdef age_band(num):    for i in range(1, 100):        if num &lt; 10*i :             return f'under {i*10}'titanic_train=pd.read_csv(\"train.csv\")titanic_train['age_band']=titanic_train['Age'].apply(age_band)titanic_age = titanic_train[['age_band', 'Survived']].groupby('age_band')['Survived'].value_counts().sort_index().unstack().fillna(0)titanic_age['Survival rate']=titanic_age[1] / (titanic_age[0] + titanic_age[1]) * 100fig, ax=plt.subplots(1, 2, figsize=(18, 7), dpi=300)# ax1ax[0].bar(titanic_age['Survival rate'].index, titanic_age['Survival rate'], color='gray')ax[0].set_title('Age Band &amp; Survival Rate(Before)')# ax2color_map=['gray' for _ in range(9)]color_map[0] = color_map[8] = '#3caea3'ax[1].bar(titanic_age['Survival rate'].index, titanic_age['Survival rate'], alpha=0.7, color=color_map, width=0.6, edgecolor='black', linewidth=1.2)ax[1].set_title('Age Band &amp; Survival Rate(After)', fontsize=15, fontweight='bold', position=(0.25, 1.0+0.05))for i in titanic_age['Survival rate'].index:    ax[1].annotate(f\"{titanic_age['Survival rate'][i]:.02f}%\",                    xy=(i, titanic_age['Survival rate'][i] + 2),                   va = 'center', ha='center',fontweight='bold', color='#383838')ax[1].yaxis.set_major_formatter(FuncFormatter(lambda y, _: f'{y:}%')) plt.suptitle('* Focus on survival rates for young and old', x=0.65, y=0.94, color='gray')plt.subplots_adjust(left=0.5, right=0.8)plt.tight_layout()plt.show()Main Color &amp; Sub Color산점도와 같이 많은 점들이 겹치면 투명도가 중요하다. 투명도를 이용해서 둘 이상의 그림을 함께 배치할 수 있다.import seaborn as snsexam_data=pd.read_csv(\"StudentsPerformance.csv\")fig, ax=plt.subplots(1, 2, figsize = (15, 7), dpi=150)ax[0].scatter(x='math score', y='reading score',data=exam_data, color='gray')ax[0].set_title('Before')ax[1].scatter(x='math score', y='reading score',data=exam_data[exam_data['gender']=='male'], color='skyblue', alpha=0.5, label='Male', s=70)ax[1].scatter(x='math score', y='reading score',data=exam_data[exam_data['gender']=='female'], color='salmon', alpha=0.5, label='Female', s=70)ax[1].set_title('After', fontsize=15, fontweight='bold')ax[1].legend()plt.gca().spines['top'].set_visible(False)plt.gca().spines['right'].set_visible(False)plt.show()Spanaxvspan: 수직axhspan: 수평sns.set_style('whitegrid') # plot with gridmovie=netflix_titles[netflix_titles['type'] == 'Movie']    rating_order=['G', 'TV-Y', 'TV-G', 'PG', 'TV-Y7', 'TV-Y7-FV', 'TV-PG', 'PG-13', 'TV-14', 'R', 'NC-17', 'TV-MA']movie_rating=movie['rating'].value_counts()[rating_order] fig, ax=plt.subplots(1, 1, figsize=(14, 7), dpi=200)ax.bar(movie_rating.index, movie_rating,  color=\"#d0d0d0\", width=0.6, edgecolor='black')ax.set_title(f'Distribution of Movie Rating (Before)', fontweight='bold')plt.show()def rating_barplot(data, title, height, h_lim=None):    fig, ax=plt.subplots(1,1, figsize=(14, 7), dpi=200)    if h_lim:        ax.set_ylim(0, h_lim)    ax.bar(data.index, data,  color=\"#e0e0e0\", width=0.52, edgecolor='black')    color=['green',  'blue',  'orange',  'red']    span_range=[[0, 2], [3,  6], [7, 8], [9, 11]]    for idx, sub_title in enumerate(['Little Kids', 'Older Kids', 'Teens', 'Mature']):        ax.annotate(sub_title,xy=(sum(span_range[idx])/2 ,height),xytext=(0,0), textcoords='offset points',                    va=\"center\", ha=\"center\",color=\"w\", fontsize=16, fontweight='bold',                    bbox=dict(boxstyle='round4', pad=0.4, color=color[idx], alpha=0.6))        ax.axvspan(span_range[idx][0]-0.4,span_range[idx][1]+0.4,  color=color[idx], alpha=0.07)    ax.set_title(f'Distribution of {title} Rating (After)', fontsize=15, fontweight='bold', position=(0.20, 1.0+0.03))    plt.show()rating_barplot(movie_rating,'Movie', 1200, 1400)MEME : xkcd themeimport matplotlibmatplotlib.font_manager._rebuild()with plt.xkcd():    fig=plt.figure()    ax=fig.add_axes((0.1, 0.2, 0.8, 0.7))    ax.spines['right'].set_color('none')    ax.spines['top'].set_color('none')    ax.set_xticks([])    ax.set_yticks([])    ax.set_ylim([-30, 10])    data=np.ones(100)    data[70:]-=np.arange(30)    ax.annotate('THE DAY I REALIZED\\nI COULD COOK BACON\\nWHENEVER I WANTED',        xy=(70, 1), arrowprops=dict(arrowstyle='-&gt;'), xytext=(15, -10))    ax.plot(data)    ax.set_xlabel('time')    ax.set_ylabel('my overall health')    fig.text(0.5, 0.05,'\"Stove Ownership\" from xkcd by Randall Munroe',ha='center')with plt.xkcd():    fig=plt.figure()    ax=fig.add_axes((0.1, 0.2, 0.8, 0.7))    ax.bar([0, 1], [0, 100], 0.25)    ax.spines['right'].set_color('none')    ax.spines['top'].set_color('none')    ax.xaxis.set_ticks_position('bottom')    ax.set_xticks([0, 1])    ax.set_xticklabels(['CONFIRMED BY\\nEXPERIMENT', 'REFUTED BY\\nEXPERIMENT'])    ax.set_xlim([-0.5, 1.5])    ax.set_yticks([])    ax.set_ylim([0, 110])    ax.set_title(\"CLAIMS OF SUPERNATURAL POWERS\")    fig.text(0.5, -0.05,'\"The Data So Far\" from xkcd by Randall Munroe',ha='center')plt.show()",
        "url": "/programming-kaggle1"
    }
    ,
    
    "programming-baekjoon2": {
        "title": "백준 (2) &lt;br&gt; (1018, 1085, 1181, 1259, &lt;br&gt; 1436, 1654, 1874, 1920)",
            "author": "keonju",
            "category": "",
            "content": "백준 관련 글    백준 (1) (2557, 8958, 1000, 1001, 1008, 2935, 2753, 2884, 5063, 4101)    백준 (2) (1018, 1085, 1181, 1259, 1436, 1654, 1874, 1920)    백준 (3) 문자열 알고리즘(11720, 8958, 1152, 10809, 1157, 9012, 11718)    백준 (4) (1157, 1546, 2577, 2675, 2908, 1018, 1436, 1259, 7568, 10250)    백준 (5) 정렬 알고리즘(2750,11399,2751,1427, 10989,1181,11650)    백준 (6) (3085, 2563, 4673, 5635, 11170)# solved.ac의 class 2단계 8문항을 풀어보았다.  파이썬 알고리즘 과제는 알고리즘 공부를 많이 하지 않은 나로써는 조금 어려웠다.  &lt;https://solved.ac/search?query=in_class:2&gt;   ## 1018번 체스판 다시 칠하기  &lt;https://www.acmicpc.net/problem/1018&gt;  ###### N,M 크기를  받고 보드 만들기  nXm형태의 위치를 파악하기 쉽게 리스트 형태로 받았다.  ```pythonn, m=map(int,input().split())if 8&lt;=n&lt;=50 and 8&lt;=m&lt;=50:    board = [input() for i in range(n)]```    10 13    BBBBBBBBWBWBW    BBBBBBBBBWBWB    BBBBBBBBWBWBW    BBBBBBBBBWBWB    BBBBBBBBWBWBW    BBBBBBBBBWBWB    BBBBBBBBWBWBW    BBBBBBBBBWBWB    WWWWWWWWWWBWB    WWWWWWWWWWBWB    ###### 위치가 짝수일 때와 홀수일 때로 나눠서  W, B가 아닐 때마다 점수를 추가해준 다음 가장 최소가 되는 값만 찾아내면 된다.  따라서 n * m의 보드에서 가능한 경우의 수는 n-7 * m-7이다. ex)10 13을 입력받을 경우 18가지.  8 * 8로 잘라주기 위해서 k와 l을 (i,i+8), (j,j+8)로 한정짓는다.  k+l이 홀수일 경우와 짝수일 경우, W로 시작할 경우와 B로 시작할 경우를 나눠서 모든 경우의 수를 반복문으로 확인해준다.  마지막으로 total_score에 들어있는 값들 중 최솟값을 구해준다.  ```pythontotal_score=[]# 보드에서 경우의 수 나누어주기for i in range(n-7):    for j in range(m-7):        count_w=0 #w가 아닐때        count_b=0 #b가 아닐때        #8*8 크기로 잘라주기        for k in range(i,i+8):             for l in range (j,j+8):                #각 경우의 수마다 비교해서 점수 추가하기                if (k+l)%2==0:                    if board[k][l]!='W':                                                    count_w=count_w+1                    if board[k][l]!='B':                        count_b=count_b+1                else:                    if board[k][l]!='W':                        count_b=count_b+1                    if board[k][l]!='B':                                                    count_w=count_w+1        # 점수들 한 list에 모아주기        total_score.append(count_w)        total_score.append(count_b)print(min(total_score)) #최솟값 출력```    12    ## 1085번 직사각형에서 탈출  &lt;https://www.acmicpc.net/problem/1085&gt;  ###### x,y,w,h 입력받기  ```pythonx,y,w,h =map(int,input().split())```    6 2 10 3    ###### 0과 가까운 경계선은 x, y로 w,h와 가까운 경계선은 w-x, h-y로 표현해주는 대신 음수가 나올수 있기때문에 abs()를 이용하여 절댓값으로 표현.  ```pythonprint(min(x,y,abs(w-x),abs(h-y)))```    1## 1181번 단어 정렬  &lt;https://www.acmicpc.net/problem/1181&gt;  ###### 단어 리스트 입력받기  ```pythonn=int(input())word_list=[input() for i in range(n)]```    13    but    i    wont    hesitate    no    more    no    more    it    cannot    wait    im    yours    ###### 길이가 짧은 것부터 같으면 사전 순으로 정렬하기 (단, 중복 제외)    set함수로 중복을 먼저 제거하였다.  단어의 길이를 먼저, 그다음에 단어를 하나의 tuple로 만들어 리스트를 다시 만들어주었다.  sort를 이용하면 앞에 숫자가 들어갔기 떄문에 길이, 알파벳 순으로 정렬된다.  ```python# 중복 단어 제거word_list=list(set(word_list))len_word_list=[]# (단어 길이, 단어) 형태의 tuple 만들기for i in word_list:    len_word_list.append((len(i),i))# 정렬하기len_word_list.sort()print(len_word_list)# 출력하기for j,k in len_word_list:    print(k)```    [(1, 'i'), (2, 'im'), (2, 'it'), (2, 'no'), (3, 'but'), (4, 'more'), (4, 'wait'), (4, 'wont'), (5, 'yours'), (6, 'cannot'), (8, 'hesitate')]    i    im    it    no    but    more    wait    wont    yours    cannot    hesitate    ## 1259번 팰린드롬수    &lt;https://www.acmicpc.net/problem/1259&gt;  ###### 앞에서 읽어도 뒤에서 읽어도 같은 숫자 찾기0을 입력하면 반복문이 끝나게 while과 if를 이용하였다.  입력받은 숫자는 위치를 찾기 편하게 문자형으로 입력받았다.  입력받은 숫자의 길이/2 만큼의 반복문을 돌리면 반대쪽은 (숫자의 길이-i-1)로 대응된다.  한가지 숫자라도 값이 다르면 False 값을 가지고 'no'를 출력하면 'yes'를 출력하는 것을 만들 때보다 길이가 짧아질 수 있다.  ```pythonwhile True:    word=input() # 숫자를 무한으로 입력받기 위해 while문 사용    quest=True # 한가지 입력값을 처리하고나서 True, False값을 True로 초기화    if word=='0': # 0을 입력하면 반복문 종료        break    else:        word_len=len(word)        for i in range(int((word_len)/2)): #단어 길이의 반만 확인하면 반대쪽 숫자와 대응된다.                if word[i]!=word[word_len-1-i]: #반대쪽 숫자와 대응하기 위해서 word_len-1-i 사용                    quest=False # 하나의 경우라도 False가 나오면 반복문 종료                    continue        if quest==False: # False가 나오면 바로 'no' 출력            print('no')        else: print('yes')```    121    yes    1231    no    12421    yes    0    ## 1436번 영화감독 숌  &lt;https://www.acmicpc.net/problem/1436&gt;  ###### 666이 적어도 3개이상 연속으로 들어가는 수를 만든다  처음에 문제를 풀 때 중간에 666이 3개 이상 들어가는 경우를 제외해서 틀렸다.  list666에 가장 작은 숫자인 666부터 '666'이 문자열로 들어가있는 숫자들을 확인해서 추가하였다.  입력받은 숫자가 list666의 길이보다 크면 계속 추가해주었고 list666[num-1]을 통하여 값을 출력해준다.  ```pythonnum=int(input())list666=[]i=666while len(list666)&lt;num:    if '666' in str(i):        list666.append(i)    i=i+1print(list666[num-1])```    3    2666    ## 1654번 랜선 자르기&lt;https://www.acmicpc.net/problem/1654&gt;  ###### 숫자 입력받기   ```pythonk,n=map(int,input().split())lan=[int(input()) for i in range(k)]```    4 11    802    743    457    539    ###### 시간초과된 코드  for문을 이용하니까 연산자가 너무 많아서 시간이 초과되었던 것 같다.  ```pythondiv_list=[]for i in range(min(lan)):    div=int(min(lan))-i    count=[]    for w in lan:        count.append(w//div)    n_result=0    for j in range(k):        n_result=n_result+count[j]    if n_result==n:        div_list.append(div)print(max(div_list))```    200    ###### 이진탐색을 이용하여보자.   이진탐색이란 마치 병뚜껑 숫자맞추기를 할 때 50을 먼저 외치고 다음에 25나 75를 외치는 것처럼 가운데에 위치한 값들을 기반으로 탐색하는 것이다.  정렬된 데이터일 때 사용 가능하다.  따라서 입력받은 값들을 기준으로 max값과 1을 양 끝 값으로 놓는다.  시작과 끝이 같을 때 까지 while문을 돌련준다.  중간값을 구하고 이 값으로 입력받은 값들을 나누어준다.  이때 잘라진 갯수가 n보다 크면 시작값에 중간값+1을, 작으면 끝값을 중간값-1을 해준다.  while문이 다 돌고 나면 그 중 작은 값이 정답이다.```pythonstart , end= 1,max(lan) #시작값과 끝값 구하기while start&lt;=end: #루프를 돌기위한 조건문    mid=(start+end)//2 #중간값 설정    cutting=0 #잘라진 선의 갯수 선언    for i in lan:        cutting+=i//mid #잘라진 선의 갯수 구하는 for문    if cutting&gt;=n: #n과 잘라진 선의 크기 비교를 통한 중간값 찾기        start=mid+1     else:        end=mid-1print(min(start,end))```    200    ## 1874번 스택 수열&lt;https://www.acmicpc.net/problem/1874&gt;  ###### 스택과 푸쉬, 팝 이해하기  push를 세 번 하면 [1,2,3] 스택이 쌓이게 되고 여기서 pop을 하면 3이 출력된다.  n을 통해 입력할 숫자의 갯수를 입력받고 num을 통해 숫자를 입력받는다.  count는 입력받을 숫자가 stack에 입력되도록 해준다. 0으로 두면 0부터 시작이다.  따라서 1로 한다.result를 통해 +와 -를 입력받고 stack에는 count에 생긴 숫자들을 쌓아둔다.while문을 통해 stack을 완성하고 if문을 통해 해당 숫자가 나오면 -를 입력한 뒤  pop해서 숫자를 제거한다.```pythonn=int(input())count=1 #count=1로 해줘야 0부터 숫자를 세지않는다.result=[] # +와 -를 저장하기 위한 리스트stack=[] # 쌓인 숫자를 저장하기 위한 리스트temp=True # 불가능한 경우에 False처리하기 위한 tempfor i in range(n):    num=int(input())     while count&lt;=num: #num과 같거나 작아질때 까지 stack에 숫자를 입력받는다.        stack.append(count)        result.append('+') #입력받은 숫자만큼 결과에 +를 입력해준다.        count=count+1    if stack[-1]==num: #스택의 마지막 숫자가 num과 같을 경우 해당 숫자를 pop하고 -를 입력해준다.        stack.pop()        result.append('-')    else:        temp=False # if문이 적용되지 않는 경우에는 False를 전달해준다.        if temp==False:    print('NO')else:    for j in result:        print(j)```    8    4    3    6    8    7    5    2    1    +    +    +    +    -    -    +    +    -    +    +    -    -    -    -    -    ## 1920번 스택 수열&lt;https://www.acmicpc.net/problem/1920&gt;  ###### 시간초과    list를 사용했을 때는 시간초과가 나왔고 set을 이용했을 때는 정상적으로 나왔다.  리스트의 in연산자를 통한 포함 여부의 시간 복잡도는 O(N)이다.  이분 탐색의 시간 복잡도는 O(logN) 이다.  Set과 Dictionary의 in연산을 통한 포함 여부 확인의 시간 복잡도는 O(1)이다.  따라서 N만 set으로 받아줘도 시간이 매우 단축된다.```pythonn=int(input())N=set(map(int,input().split()))m=int(input())M=list(map(int,input().split()))```    5    4 1 5 2 3    5    1 3 7 9 5    ```pythonfor i in range(m):    if M[i] in N:        print(1)    else:        print(0)```    1    1    0    0    1    ",
        "url": "/programming-baekjoon2"
    }
    ,
    
    "programming-baekjoon1": {
        "title": "백준 (1) &lt;br&gt; (2557, 8958, 1000, 1001, 1008, &lt;br&gt; 2935, 2753, 2884, 5063,4101)",
            "author": "keonju",
            "category": "",
            "content": "백준 관련 글    백준 (1) (2557, 8958, 1000, 1001, 1008, 2935, 2753, 2884, 5063, 4101)    백준 (2) (1018, 1085, 1181, 1259, 1436, 1654, 1874, 1920)    백준 (3) 문자열 알고리즘(11720, 8958, 1152, 10809, 1157, 9012, 11718)    백준 (4) (1157, 1546, 2577, 2675, 2908, 1018, 1436, 1259, 7568, 10250)    백준 (5) 정렬 알고리즘(2750,11399,2751,1427, 10989,1181,11650)    백준 (6) (3085, 2563, 4673, 5635, 11170)#  백준 10문제를 풀어보았다.## 2557. Hello World&lt;https://www.acmicpc.net/problem/2557&gt;Hello World!를 출력해야하는데 Hello World를 출력하여서 한번 틀렸다. 문제를 잘 읽어야한다.![png](assets/built/images/baekjoon1/helloworld_result.png)```pythonprint(\"Hello World!\")```    Hello World!    ## 8958. OX퀴즈&lt;https://www.acmicpc.net/problem/8958&gt;for문을 이용하여 입력받을 ox의 갯수를 입력받고 for문 중첩을 이용하여 ox의 길이를 파악하고 if문으로 ox 여부를 확인하였다.ox의 연속성에 따른 점수변화를 num_score로 두고 total_score을 num_score의 합으로 설정하였다.```pythonnum=int(input())for i in range(num):    ox=input()    total_score=0    num_score=0    for i in range(len(ox)):        if (ox[i]=='O') is True:            num_score=num_score+1        else:            num_score=0        total_score=total_score+num_score    print(total_score)```    5    OOXXOXXOOO    10    OOXXOOXXOO    9    OXOXOXOXOXOXOX    7    OOOOOOOOOO    55    OOOOXOOOOXOOOOX    30    ## 1000. A+B&lt;https://www.acmicpc.net/problem/1000&gt;map을 이용하여 a와 b를 사이 공백으로 분류시켜주는 것이 필요한 문제이다.```pythona,b=map(int,input().split())if a &gt;0 and b&lt;10:    print(a+b)```    1 2    3    ## 1001. A-B&lt;https://www.acmicpc.net/problem/1001&gt;위 문제와 마찬가지로 map을 이용하여 a와 b를 사이 공백으로 분류시켜주는 것이 필요한 문제이다.```pythona,b=map(int,input().split())if a &gt;0 and b&lt;10:    print(a-b)```    3 2    1    ## 1008. A/B&lt;https://www.acmicpc.net/problem/1008&gt;위 문제와 마찬가지로 map을 이용하여 a와 b를 사이 공백으로 분류시켜주는 것이 필요한 문제이다.###### 무한 소수일 경우```pythona,b=map(int,input().split())if a &gt;0 and b&lt;10:    print(a/b)```    1 3    0.3333333333333333    ###### 유한 소수일 경우```pythona,b=map(int,input().split())if a &gt;0 and b&lt;10:    print(a/b)```    4 5    0.8    ## 2935. 소음&lt;https://www.acmicpc.net/problem/2935&gt;a와 b는 정수형으로 입력받고 + 와 * 는 문자형으로 입력받았다.a와 b가 10의 제곱 형태이므로 반복문을 통하여 10 ** i, 10 ** j로 제곱 형태를 판별하였고 + 와 * 는 if문으로 구분지어서 계산을 해주었다.파이썬에서는 제곱을 ** 형태로 표현하는 것을 상기해야한다.###### *를 이용한 경우```pythona=int(input())cal=input()b=int(input())for i in range(99):    for j in range(99):        if (a==10**i) is True and (b==10**j) is True:            if cal=='+':                print(a+b)            if cal=='*':                print(a*b)```    1000    *    100    100000    ###### +를 이용한 경우```pythona=int(input())cal=input()b=int(input())for i in range(99):    for j in range(99):        if (a==10**i) is True and (b==10**j) is True:            if cal=='+':                print(a+b)            if cal=='*':                print(a*b)```    10000    +    10    10010    ## 2753. 윤년&lt;https://www.acmicpc.net/problem/2753&gt;입력받은 연도를 1 이상 4000 이하로 제한하고 연도를 4로 나눈 나머지가 0, 100으로 나눈 나머지가 0이 아닌 경우로 하나, 400으로 나눈 나머지가 0인 경우 하나로 나누어서 1을 출력해주고 나머지는 0을 출력하는 형태로 만들었다.나머지는 %로 구한다는 것을 상기해주었다.###### 윤년인 경우```pythonyear=int(input())if year&gt;=1 and year&lt;=4000:    if year%4==0 and year%100!=0:        print(1)    elif year%400==0:        print(1)    else:        print(0)```    2000    1    ###### 윤년이 아닌 경우```pythonyear=int(input())if year&gt;=1 and year&lt;=4000:    if year%4==0 and year%100!=0:        print(1)    elif year%400==0:        print(1)    else:        print(0)```    1999    0    ## 2884. 알람 시계&lt;https://www.acmicpc.net/problem/2884&gt;위에 사칙연산 문제와 같이 map을 이용해서 시와 분을 분리하여 입력받는다.우선 시를 0 이상 23 이하, 분을 0 이상 59 이하로 한정해었다.첫번째 경우 분이 45 이상일 경우 분에서 45를 빼주더라도 시간은 변하지 않는다. 따라서 시간, 분-45 를 출력해주면 된다.두번째 경우 분이 45 미만일 경우 시가 하나 작아진다. 0 시 45 분 이전에는 날짜가 바뀌므로 23 에서 시를 빼주고 나머지 경우는 시에서 1 빼준다.분이 45 미만일 경우 60 - (45 - 분) 해주면 바뀐 분이 나온다. 따라서 분 + 15 로 표현해 주었다.![png](assets/built/images/baekjoon1/clock_result.png)###### 시와 분 모두 바뀔 때```pythonh,m=map(int,input().split())if 0&lt;=h&lt;=23 and 0&lt;=m&lt;=59 :    if m-45&gt;=0:        print(h,m-45)    else:        if h-1&lt;0:            print(23-h,m+15)        else:            print(h-1,m+15)```    10 10    9 25    ###### 날짜 까지 바뀔 때```pythonh,m=map(int,input().split())if 0&lt;=h&lt;=23 and 0&lt;=m&lt;=59 :    if m-45&gt;=0:        print(h,m-45)    else:        if h-1&lt;0:            print(23-h,m+15)        else:            print(h-1,m+15)```    0 30    23 45    ## 5063. TGN&lt;https://www.acmicpc.net/problem/5063&gt;test_case를 입력받아서 for문의 횟수를 한정시킨다.r, e, c를 map을 이용하여 입력받았으며 범위를 한정시켜주었다. 이때 (-10) ** 6으로 잘못 작성하여서 코드가 실행되지 않았다.광고 비용이 광고 수익과 일반 수익의 차보다 작을 때 광고를 하고 같으면 소용이 없고 크면 광고를 하지 않아야하므로 if문으로 구분시켰다.```pythontest_case=int(input())for i in range(test_case):    r,e,c=map(int,input().split())    if -(10**6)&lt;=r&lt;=(10**6) and -(10**6)&lt;=e&lt;=(10**6) and 0&lt;=c&lt;=(10**6):        if e-r&gt;c:            print('advertise')        elif e-r==c:            print('does not matter')        else:            print('do not advertise')```    3    0 100 70    advertise    100 130 30    does not matter    -100 -70 40    do not advertise    ## 4101. 크냐?&lt;https://www.acmicpc.net/problem/4101&gt;while 반복문을 사용하여 계속 두 숫자를 입력받았으며 map을 통하여 공백을 기준으로 숫자를 나누었다.먼저 두 숫자가 0이면 해당 while문이 정지를 하게 만들어주고, 그 뒤에 두 숫자의 범위가 True면 두 숫자의 대소비교를 진행하였다.```pythonwhile True:    a,b=map(int,input().split())    if a==0 and b==0:            break    if 0&lt;a&lt;=10**6 and 0&lt;b&lt;=10**6:        if a&gt;b:            print(\"Yes\")        else:            print(\"No\")```    1 19    No    4 4    No    23 14    Yes    0 0    ",
        "url": "/programming-baekjoon1"
    }
    ,
    
    "programming-webcrawling1": {
        "title": "웹크롤링 (1) &lt;br&gt; urllib사용을 통한 크롤링",
            "author": "keonju",
            "category": "",
            "content": "웹크롤링 관련 글    웹크롤링 (1)-urllib사용을 통한 크롤링urllib사용을 통한 크롤링  url을 입력하여 작동하는 라이브러리로 통신을 통해 데이터를 주고받는 기능을 한다.  데이터를 받아오거나 다운로드할 수 있다1.urlretrieve  url로 표시된 네트워크 정보를 파일로 저장할 수 있는 기능 (이미지 , html)  (filename, headers) 튜플로 반환  ex file, header = req.urlretrieve(url, path)import urllib.request as requrl 에 접근할 url주소를 담고, path에 저장할 경로와 파일명을 적으면 된다.파일명만 적을 경우 현재 위치로 저장이 된다.url = \"https://search.pstatic.net/common/?src=http%3A%2F%2Fblogfiles.naver.net%2FMjAyMTA4MjBfMTQx%2FMDAxNjI5NDIxNjQ5NzM5.D1F-l6COowiUicFVRlpfQeSJRtkR4f9lkbVZgwJm6r4g.lBjYtG_wiubtJdiCYg8reMDwyC3wkFhPy5Ou0VXWRIQg.JPEG.hyun_0930%2F1629420539963.jpg&amp;type=sc960_832\"path = \"test1.jpg\"url'https://search.pstatic.net/common/?src=http%3A%2F%2Fblogfiles.naver.net%2FMjAyMTA4MjBfMTQx%2FMDAxNjI5NDIxNjQ5NzM5.D1F-l6COowiUicFVRlpfQeSJRtkR4f9lkbVZgwJm6r4g.lBjYtG_wiubtJdiCYg8reMDwyC3wkFhPy5Ou0VXWRIQg.JPEG.hyun_0930%2F1629420539963.jpg&amp;type=sc960_832'path'test1.jpg'현재위치 조회import osos.getcwd()file, header = req.urlretrieve(url,path)print(file)test1.jpgprint(header)accept-ranges: bytescache-control: max-age=2592000content-length: 37532content-type: image/jpegexpires: Sun, 26 Sep 2021 23:53:24 GMTlast-modified: Fri, 27 Aug 2021 23:53:24 GMTp3p: CP=\"ALL CURa ADMa DEVa TAIa OUR BUS IND PHY ONL UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE LOC OTC\"date: Fri, 27 Aug 2021 23:53:24 GMTage: 665797server: Testa/5.1.1strict-transport-security: max-age=31536000connection: closehtml저장url2 = \"https://www.naver.com/\"path2 = \"naver.html\"file2, header2 = req.urlretrieve(url2, path2)print(\"----------------------------------------------------\")print(f\"file name: {file}\")print(\"----------------------------------------------------\")print(\"Header Info :\")print(header)print(\"----------------------------------------------------\")print(f\"file name: {file2}\")print(\"----------------------------------------------------\")print(\"Header Info :\")print(header2)----------------------------------------------------file name: test1.jpg----------------------------------------------------Header Info :accept-ranges: bytescache-control: max-age=2592000content-length: 37532content-type: image/jpegexpires: Sun, 26 Sep 2021 23:53:24 GMTlast-modified: Fri, 27 Aug 2021 23:53:24 GMTp3p: CP=\"ALL CURa ADMa DEVa TAIa OUR BUS IND PHY ONL UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE LOC OTC\"date: Fri, 27 Aug 2021 23:53:24 GMTage: 665797server: Testa/5.1.1strict-transport-security: max-age=31536000connection: close----------------------------------------------------file name: naver.html----------------------------------------------------Header Info :Server: NWSDate: Sat, 04 Sep 2021 16:50:00 GMTContent-Type: text/html; charset=UTF-8Transfer-Encoding: chunkedConnection: closeSet-Cookie: PM_CK_loc=4d397054570413bd11c4b9094901203f9fef0e3df1bd78a55cef2ac0fd1d9e5e; Expires=Sun, 05 Sep 2021 16:50:00 GMT; Path=/; HttpOnlyCache-Control: no-cache, no-store, must-revalidatePragma: no-cacheP3P: CP=\"CAO DSP CURa ADMa TAIa PSAa OUR LAW STP PHY ONL UNI PUR FIN COM NAV INT DEM STA PRE\"X-Frame-Options: DENYX-XSS-Protection: 1; mode=blockStrict-Transport-Security: max-age=63072000; includeSubdomainsReferrer-Policy: unsafe-url2.urlerror  크롤링에서 발생할 수 있는 에러처리  에러처리를 통해서 어떤 에러가 발생하였는지 파악하고 코드를 수정  URLError: 요청한 곳의 서버가 없거나 네트워크 연결이 없는 상황  HTTPError: HTTP응답에 있는 status에 따라서 상태를 반환, status코드에 따라서 에러 유형이 다름  주의사항: URLError가 HTTPError도 잡기 때문에 HTTPError처리를 먼저 해줘야함1번 예제와 다르게 list에 넣고 for문을 통한 이미지 다운로드를 실시from urllib.error import URLError, HTTPErrorurl_list = ['https://search.pstatic.net/common/?src=http%3A%2F%2Fblogfiles.naver.net%2FMjAyMTA4MjBfMTQx%2FMDAxNjI5NDIxNjQ5NzM5.D1F-l6COowiUicFVRlpfQeSJRtkR4f9lkbVZgwJm6r4g.lBjYtG_wiubtJdiCYg8reMDwyC3wkFhPy5Ou0VXWRIQg.JPEG.hyun_0930%2F1629420539963.jpg&amp;type=sc960_832',            'https://search.pstatic.net/common/?src=http%3A%2F%2Fblogfiles.naver.net%2FMjAyMDA5MTNfNjMg%2FMDAxNjAwMDAxNjM1NzQ2.TuGLdOsJ8vLFnN589WEiiA5j5XrsWRA7lJUJicpozJwg.694y_QRQKQwqd7QR41nweA3T4vYnAGT4OqVuxWvJdrYg.JPEG.ecoanimal%2F51d63faf6312a3bc4873ee24d98cdfed.jpg&amp;type=a340']name_list = ['nuguli1.jpg', 'nuguli2.jpg']for i,url in enumerate(url_list):    # 예외 처리    try:        # 웹 수신 정보 읽기        response = req.urlopen(url)                # 수신 내용        contents = response.read()        print('----------------------------------------------------------------------------------------------------------------')        # 상태 정보 중간 출력        print(f'file_name : {name_list[i]}')        print('&lt;Header Info&gt;')        print(f'{response.info()}')        print(f'Status Code : {response.getcode()}')        print()        print('----------------------------------------------------------------------------------------------------------------')        # 파일 쓰기        with open(name_list[i], 'wb') as c:            c.write(contents)            except HTTPError as e: # HTTP 에러        print(\"다운로드 실패.\")        print('HTTPError Code : ', e.code)    except URLError as e: # URL 에러        print(\"Download failed.\")        print('URL Error Reason : ', e.reason)        # 성공    else:        print()        print(f'{name_list[i]}이미지 다운 완료.')----------------------------------------------------------------------------------------------------------------file_name : nuguli1.jpg&lt;Header Info&gt;accept-ranges: bytescache-control: max-age=2592000content-length: 37532content-type: image/jpegexpires: Sun, 26 Sep 2021 23:53:24 GMTlast-modified: Fri, 27 Aug 2021 23:53:24 GMTp3p: CP=\"ALL CURa ADMa DEVa TAIa OUR BUS IND PHY ONL UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE LOC OTC\"date: Fri, 27 Aug 2021 23:53:24 GMTage: 665797server: Testa/5.1.1strict-transport-security: max-age=31536000connection: closeStatus Code : 200----------------------------------------------------------------------------------------------------------------nuguli1.jpg이미지 다운 완료.----------------------------------------------------------------------------------------------------------------file_name : nuguli2.jpg&lt;Header Info&gt;accept-ranges: bytescache-control: max-age=2592000content-length: 50098content-type: image/jpegexpires: Fri, 24 Sep 2021 14:11:17 GMTlast-modified: Wed, 25 Aug 2021 14:11:17 GMTp3p: CP=\"ALL CURa ADMa DEVa TAIa OUR BUS IND PHY ONL UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE LOC OTC\"date: Wed, 25 Aug 2021 14:11:17 GMTage: 873524server: Testa/5.1.1strict-transport-security: max-age=31536000connection: closeStatus Code : 200----------------------------------------------------------------------------------------------------------------nuguli2.jpg이미지 다운 완료.3.urlopen/ urlparseimport urllib.request as reqfrom urllib.parse import urlparseurl=\"https://www.seoultech.ac.kr/index.jsp\"ele=req.urlopen(url)print('type : {}'.format(type(ele)))print()print(\"geturl : {}\".format(ele.geturl()))print()print(\"status : {}\".format(ele.status))print()print(\"headers : {}\".format(ele.getheaders()))print()print()print('parse : {}'.format(urlparse('https://www.smu.ac.kr/ko/index.do?param=test').query))print()type : &lt;class 'http.client.HTTPResponse'&gt;geturl : https://www.seoultech.ac.kr/index.jspstatus : 200headers : [('Date', 'Sat, 04 Sep 2021 16:50:01 GMT'), ('Content-Type', 'text/html; charset=UTF-8'), ('Set-Cookie', 'JSESSIONID=5BabR1bj8eGHwllZbNNO9LXiYD2V1HlqI1KZJiR7EG01ZnEBpYTlBwaFVwCi61YT.web1_servlet_www;Path=/;HttpOnly'), ('X-Cache', 'MISS from cf4.seoultech.ac.kr'), ('X-Cache-Lookup', 'HIT from cf4.seoultech.ac.kr:3128'), ('Transfer-Encoding', 'chunked'), ('Via', ''), ('Connection', 'close')]parse : param=testprint(ele.info())Date: Sat, 04 Sep 2021 16:50:01 GMTContent-Type: text/html; charset=UTF-8Set-Cookie: JSESSIONID=5BabR1bj8eGHwllZbNNO9LXiYD2V1HlqI1KZJiR7EG01ZnEBpYTlBwaFVwCi61YT.web1_servlet_www;Path=/;HttpOnlyX-Cache: MISS from cf4.seoultech.ac.krX-Cache-Lookup: HIT from cf4.seoultech.ac.kr:3128Transfer-Encoding: chunkedVia: Connection: closeheaders에 데이터 추가하기# pip install fake_useragentfrom fake_useragent import UserAgentua = UserAgent()### fake_useragentua = UserAgent()print(ua.random)print(ua.ie)print(ua.msie)print(ua['Internet Explorer'])print(ua.opera)print(ua.chrome)print(ua.google)print(ua['google chrome'])print(ua.firefox)print(ua.ff)print(ua.safari)Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/4.0; GTB7.4; InfoPath.1; SV1; .NET CLR 2.8.52393; WOW64; en-US)Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.2; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0; FunWebProducts)Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/5.0 Opera 11.11Mozilla/5.0 (Windows NT 6.4; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1468.0 Safari/537.36Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:23.0) Gecko/20131011 Firefox/23.0Mozilla/5.0 (Windows NT 6.1; WOW64; rv:31.0) Gecko/20130401 Firefox/31.0Mozilla/5.0 (Windows; U; Windows NT 6.0; de-DE) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/5.0.3 Safari/533.19.4야후 파이낸스 데이터 받아오기import jsonimport urllib.request as reqfrom fake_useragent import UserAgent  url 주소를 찾는 것에서 시간이 조금 걸림이미지같은 경우 주소가 연동되지만 변동되는 데이터는 적용되지않음크롬 개발자도구에서 Network항목에서 RequestURL 찾기import jsonimport urllib.request as reqfrom fake_useragent import UserAgent# Fake Header 정보(가상으로 User-Agent 생성)ua = UserAgent()# 헤더 선언headers = {    'User-Agent': ua.ie,    'referer': 'https://finance.yahoo.com/'}# 다음 주식 요청 URLurl = \"https://query1.finance.yahoo.com/v7/finance/quote?formatted=true&amp;crumb=5b5ru0zoR.q&amp;lang=en-US&amp;region=US&amp;symbols=ADA-USD%2CBTC-USD%2CDOGE-USD%2CETH-USD%2CZM&amp;fields=symbol%2CshortName%2ClongName%2CregularMarketPrice%2CregularMarketChange%2CregularMarketChangePercent&amp;corsDomain=finance.yahoo.com\"res = req.urlopen(req.Request(url, headers=headers)).read().decode('utf-8')# 응답 데이터 str -&gt; json 변환 및 data 값 저장_json_data = json.loads(res)print( _json_data, '\\n'){'quoteResponse': {'result': [{'fullExchangeName': 'CCC', 'exchangeTimezoneName': 'Europe/London', 'symbol': 'ADA-USD', 'regularMarketChange': {'raw': -0.12517643, 'fmt': '-0.13'}, 'gmtOffSetMilliseconds': 3600000, 'firstTradeDateMilliseconds': 1506812400000, 'exchangeDataDelayedBy': 0, 'language': 'en-US', 'regularMarketTime': {'raw': 1630774030, 'fmt': '5:47PM BST'}, 'regularMarketChangePercent': {'raw': -4.1827593, 'fmt': '-4.18%'}, 'exchangeTimezoneShortName': 'BST', 'quoteType': 'CRYPTOCURRENCY', 'marketState': 'REGULAR', 'regularMarketPrice': {'raw': 2.8674967, 'fmt': '2.87'}, 'market': 'ccc_market', 'quoteSourceName': 'CoinMarketCap', 'tradeable': False, 'exchange': 'CCC', 'sourceInterval': 15, 'shortName': 'Cardano USD', 'region': 'US', 'regularMarketPreviousClose': {'raw': 2.9606647, 'fmt': '2.96'}, 'triggerable': True}, {'fullExchangeName': 'CCC', 'exchangeTimezoneName': 'Europe/London', 'symbol': 'BTC-USD', 'regularMarketChange': {'raw': -611.96094, 'fmt': '-611.96'}, 'gmtOffSetMilliseconds': 3600000, 'firstTradeDateMilliseconds': 1410908400000, 'exchangeDataDelayedBy': 0, 'language': 'en-US', 'regularMarketTime': {'raw': 1630774082, 'fmt': '5:48PM BST'}, 'regularMarketChangePercent': {'raw': -1.2106228, 'fmt': '-1.21%'}, 'exchangeTimezoneShortName': 'BST', 'quoteType': 'CRYPTOCURRENCY', 'marketState': 'REGULAR', 'regularMarketPrice': {'raw': 49937.133, 'fmt': '49,937.13'}, 'market': 'ccc_market', 'quoteSourceName': 'CoinMarketCap', 'tradeable': False, 'exchange': 'CCC', 'sourceInterval': 15, 'shortName': 'Bitcoin USD', 'region': 'US', 'regularMarketPreviousClose': {'raw': 49922.355, 'fmt': '49,922.36'}, 'triggerable': True}, {'fullExchangeName': 'CCC', 'exchangeTimezoneName': 'Europe/London', 'symbol': 'DOGE-USD', 'regularMarketChange': {'raw': 0.0015876293, 'fmt': '0.00'}, 'gmtOffSetMilliseconds': 3600000, 'firstTradeDateMilliseconds': 1410908400000, 'exchangeDataDelayedBy': 0, 'language': 'en-US', 'regularMarketTime': {'raw': 1630774083, 'fmt': '5:48PM BST'}, 'regularMarketChangePercent': {'raw': 0.52755743, 'fmt': '0.53%'}, 'exchangeTimezoneShortName': 'BST', 'quoteType': 'CRYPTOCURRENCY', 'marketState': 'REGULAR', 'regularMarketPrice': {'raw': 0.30252412, 'fmt': '0.30'}, 'market': 'ccc_market', 'quoteSourceName': 'CoinMarketCap', 'tradeable': False, 'exchange': 'CCC', 'sourceInterval': 15, 'shortName': 'Dogecoin USD', 'region': 'US', 'regularMarketPreviousClose': {'raw': 0.29575953, 'fmt': '0.30'}, 'triggerable': True}, {'fullExchangeName': 'CCC', 'exchangeTimezoneName': 'Europe/London', 'symbol': 'ETH-USD', 'regularMarketChange': {'raw': -63.86255, 'fmt': '-63.86'}, 'gmtOffSetMilliseconds': 3600000, 'firstTradeDateMilliseconds': 1438902000000, 'exchangeDataDelayedBy': 0, 'language': 'en-US', 'regularMarketTime': {'raw': 1630774082, 'fmt': '5:48PM BST'}, 'regularMarketChangePercent': {'raw': -1.608492, 'fmt': '-1.61%'}, 'exchangeTimezoneShortName': 'BST', 'quoteType': 'CRYPTOCURRENCY', 'marketState': 'REGULAR', 'regularMarketPrice': {'raw': 3906.476, 'fmt': '3,906.48'}, 'market': 'ccc_market', 'quoteSourceName': 'CoinMarketCap', 'tradeable': False, 'exchange': 'CCC', 'sourceInterval': 15, 'shortName': 'Ethereum USD', 'region': 'US', 'regularMarketPreviousClose': {'raw': 3933.8274, 'fmt': '3,933.83'}, 'triggerable': True}, {'fullExchangeName': 'NasdaqGS', 'symbol': 'ZM', 'gmtOffSetMilliseconds': -14400000, 'language': 'en-US', 'regularMarketTime': {'raw': 1630699203, 'fmt': '4:00PM EDT'}, 'regularMarketChangePercent': {'raw': 1.084419, 'fmt': '1.08%'}, 'quoteType': 'EQUITY', 'tradeable': False, 'regularMarketPreviousClose': {'raw': 295.09, 'fmt': '295.09'}, 'exchangeTimezoneName': 'America/New_York', 'regularMarketChange': {'raw': 3.2000122, 'fmt': '3.20'}, 'firstTradeDateMilliseconds': 1555594200000, 'exchangeDataDelayedBy': 0, 'exchangeTimezoneShortName': 'EDT', 'marketState': 'CLOSED', 'regularMarketPrice': {'raw': 298.29, 'fmt': '298.29'}, 'market': 'us_market', 'quoteSourceName': 'Delayed Quote', 'priceHint': 2, 'exchange': 'NMS', 'sourceInterval': 15, 'shortName': 'Zoom Video Communications, Inc.', 'region': 'US', 'triggerable': True, 'longName': 'Zoom Video Communications, Inc.'}], 'error': None}} data_list=_json_data['quoteResponse']['result']from pprint import pprintpprint(data_list)[{'exchange': 'CCC',  'exchangeDataDelayedBy': 0,  'exchangeTimezoneName': 'Europe/London',  'exchangeTimezoneShortName': 'BST',  'firstTradeDateMilliseconds': 1506812400000,  'fullExchangeName': 'CCC',  'gmtOffSetMilliseconds': 3600000,  'language': 'en-US',  'market': 'ccc_market',  'marketState': 'REGULAR',  'quoteSourceName': 'CoinMarketCap',  'quoteType': 'CRYPTOCURRENCY',  'region': 'US',  'regularMarketChange': {'fmt': '-0.13', 'raw': -0.12517643},  'regularMarketChangePercent': {'fmt': '-4.18%', 'raw': -4.1827593},  'regularMarketPreviousClose': {'fmt': '2.96', 'raw': 2.9606647},  'regularMarketPrice': {'fmt': '2.87', 'raw': 2.8674967},  'regularMarketTime': {'fmt': '5:47PM BST', 'raw': 1630774030},  'shortName': 'Cardano USD',  'sourceInterval': 15,  'symbol': 'ADA-USD',  'tradeable': False,  'triggerable': True}, {'exchange': 'CCC',  'exchangeDataDelayedBy': 0,  'exchangeTimezoneName': 'Europe/London',  'exchangeTimezoneShortName': 'BST',  'firstTradeDateMilliseconds': 1410908400000,  'fullExchangeName': 'CCC',  'gmtOffSetMilliseconds': 3600000,  'language': 'en-US',  'market': 'ccc_market',  'marketState': 'REGULAR',  'quoteSourceName': 'CoinMarketCap',  'quoteType': 'CRYPTOCURRENCY',  'region': 'US',  'regularMarketChange': {'fmt': '-611.96', 'raw': -611.96094},  'regularMarketChangePercent': {'fmt': '-1.21%', 'raw': -1.2106228},  'regularMarketPreviousClose': {'fmt': '49,922.36', 'raw': 49922.355},  'regularMarketPrice': {'fmt': '49,937.13', 'raw': 49937.133},  'regularMarketTime': {'fmt': '5:48PM BST', 'raw': 1630774082},  'shortName': 'Bitcoin USD',  'sourceInterval': 15,  'symbol': 'BTC-USD',  'tradeable': False,  'triggerable': True}, {'exchange': 'CCC',  'exchangeDataDelayedBy': 0,  'exchangeTimezoneName': 'Europe/London',  'exchangeTimezoneShortName': 'BST',  'firstTradeDateMilliseconds': 1410908400000,  'fullExchangeName': 'CCC',  'gmtOffSetMilliseconds': 3600000,  'language': 'en-US',  'market': 'ccc_market',  'marketState': 'REGULAR',  'quoteSourceName': 'CoinMarketCap',  'quoteType': 'CRYPTOCURRENCY',  'region': 'US',  'regularMarketChange': {'fmt': '0.00', 'raw': 0.0015876293},  'regularMarketChangePercent': {'fmt': '0.53%', 'raw': 0.52755743},  'regularMarketPreviousClose': {'fmt': '0.30', 'raw': 0.29575953},  'regularMarketPrice': {'fmt': '0.30', 'raw': 0.30252412},  'regularMarketTime': {'fmt': '5:48PM BST', 'raw': 1630774083},  'shortName': 'Dogecoin USD',  'sourceInterval': 15,  'symbol': 'DOGE-USD',  'tradeable': False,  'triggerable': True}, {'exchange': 'CCC',  'exchangeDataDelayedBy': 0,  'exchangeTimezoneName': 'Europe/London',  'exchangeTimezoneShortName': 'BST',  'firstTradeDateMilliseconds': 1438902000000,  'fullExchangeName': 'CCC',  'gmtOffSetMilliseconds': 3600000,  'language': 'en-US',  'market': 'ccc_market',  'marketState': 'REGULAR',  'quoteSourceName': 'CoinMarketCap',  'quoteType': 'CRYPTOCURRENCY',  'region': 'US',  'regularMarketChange': {'fmt': '-63.86', 'raw': -63.86255},  'regularMarketChangePercent': {'fmt': '-1.61%', 'raw': -1.608492},  'regularMarketPreviousClose': {'fmt': '3,933.83', 'raw': 3933.8274},  'regularMarketPrice': {'fmt': '3,906.48', 'raw': 3906.476},  'regularMarketTime': {'fmt': '5:48PM BST', 'raw': 1630774082},  'shortName': 'Ethereum USD',  'sourceInterval': 15,  'symbol': 'ETH-USD',  'tradeable': False,  'triggerable': True}, {'exchange': 'NMS',  'exchangeDataDelayedBy': 0,  'exchangeTimezoneName': 'America/New_York',  'exchangeTimezoneShortName': 'EDT',  'firstTradeDateMilliseconds': 1555594200000,  'fullExchangeName': 'NasdaqGS',  'gmtOffSetMilliseconds': -14400000,  'language': 'en-US',  'longName': 'Zoom Video Communications, Inc.',  'market': 'us_market',  'marketState': 'CLOSED',  'priceHint': 2,  'quoteSourceName': 'Delayed Quote',  'quoteType': 'EQUITY',  'region': 'US',  'regularMarketChange': {'fmt': '3.20', 'raw': 3.2000122},  'regularMarketChangePercent': {'fmt': '1.08%', 'raw': 1.084419},  'regularMarketPreviousClose': {'fmt': '295.09', 'raw': 295.09},  'regularMarketPrice': {'fmt': '298.29', 'raw': 298.29},  'regularMarketTime': {'fmt': '4:00PM EDT', 'raw': 1630699203},  'shortName': 'Zoom Video Communications, Inc.',  'sourceInterval': 15,  'symbol': 'ZM',  'tradeable': False,  'triggerable': True}]result_list = []for data in data_list:    _set={}    _set['symbol'] = data['symbol']    _set['Last_price'] = data['regularMarketPrice']['fmt']    _set['Change'] = data['regularMarketChange']['fmt']    _set['%Change'] = data['regularMarketChangePercent']['fmt']    result_list.append(_set)import pandas as pddf = pd.DataFrame(result_list)df                  symbol      Last_price      Change      %Change                  0      ADA-USD      2.87      -0.13      -4.18%              1      BTC-USD      49,937.13      -611.96      -1.21%              2      DOGE-USD      0.30      0.00      0.53%              3      ETH-USD      3,906.48      -63.86      -1.61%              4      ZM      298.29      3.20      1.08%      ",
        "url": "/programming-webcrawling1"
    }
    ,
    
    "license-first": {
        "title": "자격증 게시판 연습글",
            "author": "keonju",
            "category": "",
            "content": "자격증 공부 정리    자격증 관련 연습글자격증 첫 글 연습",
        "url": "/license-first"
    }
    ,
    
    "project-first": {
        "title": "project 연습글",
            "author": "keonju",
            "category": "",
            "content": "project 게시글 목록    project 연습글프로젝트 게시판 첫 글 연습",
        "url": "/project-first"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://keonju2.github.io/">주건나's Blog</a> &copy; 2021</section>
                <!--
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                -->
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    <a href="https://facebook.com/monkeykeonju" target="_blank" rel="noopener">Facebook</a>
                    
                    <!--
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                     -->
                </nav>

            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search 주건나's Blog</h1>
            <p class="subscribe-overlay-description">
            검색어를 입력해주세요 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    


    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-6FJ2289869', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
